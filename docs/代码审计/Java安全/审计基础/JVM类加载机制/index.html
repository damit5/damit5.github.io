<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-代码审计/Java安全/审计基础/JVM类加载机制" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">JVM类加载机制 | d4m1ts 知识库</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://blog.gm7.org/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://blog.gm7.org/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://blog.gm7.org/docs/代码审计/Java安全/审计基础/JVM类加载机制"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="JVM类加载机制 | d4m1ts 知识库"><meta data-rh="true" name="description" content="Java是一个依赖于JVM(Java虚拟机)实现的跨平台的开发语言。Java程序在运行前需要先编译成class文件，Java类初始化的时候会调用 java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法(defineClass0/1/2)来定义一个java.lang.Class实例。"><meta data-rh="true" property="og:description" content="Java是一个依赖于JVM(Java虚拟机)实现的跨平台的开发语言。Java程序在运行前需要先编译成class文件，Java类初始化的时候会调用 java.lang.ClassLoader加载类字节码，ClassLoader会调用JVM的native方法(defineClass0/1/2)来定义一个java.lang.Class实例。"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://blog.gm7.org/docs/代码审计/Java安全/审计基础/JVM类加载机制"><link data-rh="true" rel="alternate" href="https://blog.gm7.org/docs/代码审计/Java安全/审计基础/JVM类加载机制" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://blog.gm7.org/docs/代码审计/Java安全/审计基础/JVM类加载机制" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://0LMFVYF6KV-dsn.algolia.net" crossorigin="anonymous"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"代码审计","item":"https://blog.gm7.org/docs/代码审计/"},{"@type":"ListItem","position":2,"name":"审计基础","item":"https://blog.gm7.org/docs/category/审计基础"},{"@type":"ListItem","position":3,"name":"JVM类加载机制","item":"https://blog.gm7.org/docs/代码审计/Java安全/审计基础/JVM类加载机制"}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="d4m1ts 知识库 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="d4m1ts 知识库 Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="d4m1ts 知识库" href="/opensearch.xml"><link rel="stylesheet" href="/assets/css/styles.933499b4.css">
<script src="/assets/js/runtime~main.07724ef0.js" defer="defer"></script>
<script src="/assets/js/main.9f1c0106.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">知识库</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/damit5/damit5.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="切换浅色/暗黑模式（当前为system mode）"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索 (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/渗透测试/">渗透测试</a><button aria-label="展开侧边栏分类 &#x27;渗透测试&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/代码审计/">代码审计</a><button aria-label="折叠侧边栏分类 &#x27;代码审计&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/docs/category/审计基础">Java安全</a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/审计基础">审计基础</a><button aria-label="折叠侧边栏分类 &#x27;审计基础&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/代码审计/Java安全/审计基础/JVM类加载机制">JVM类加载机制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/Java反射机制">Java反射机制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/Java序列化与反序列化">Java 序列化和反序列化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/RMI基础">RMI基础</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/JNDI注入">JNDI注入</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/IDEA断点调试">IDEA断点调试</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/Java加载字节码">Java加载字节码</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/javassist字节码编程">javassist字节码编程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/EL表达式">EL表达式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/SpEL表达式">SpEL表达式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/OGNL表达式">OGNL表达式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/审计基础/IDEA调试JAR">IDEA调试JAR</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/反序列化链分析">反序列化链分析</a><button aria-label="展开侧边栏分类 &#x27;反序列化链分析&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/应用漏洞分析">应用漏洞分析</a><button aria-label="展开侧边栏分类 &#x27;应用漏洞分析&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/rce回显链">RCE回显链</a><button aria-label="展开侧边栏分类 &#x27;RCE回显链&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/内存马">内存马</a><button aria-label="展开侧边栏分类 &#x27;内存马&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/杂项">杂项</a><button aria-label="展开侧边栏分类 &#x27;杂项&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/cc">C:C++</a><button aria-label="展开侧边栏分类 &#x27;C:C++&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/codeql">codeql</a><button aria-label="展开侧边栏分类 &#x27;codeql&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/其他">其他</a><button aria-label="展开侧边栏分类 &#x27;其他&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/编程开发/GO/GO基础/">编程开发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/category/前置基础知识">移动安全</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/应急响应/简介/">应急响应</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/category/日常使用">AI</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/暂未分类/自建网盘/h5ai/">暂未分类</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/致谢">致谢</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/更新日志">更新日志</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_z5aJ"><div class="docItemContainer_c0TR"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/docs/代码审计/"><span>代码审计</span></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java安全</span></li><li class="breadcrumbs__item"><a class="breadcrumbs__link" href="/docs/category/审计基础"><span>审计基础</span></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">JVM类加载机制</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_bxCs"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><p><img decoding="async" loading="lazy" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMTA1IiBoZWlnaHQ9IjIwIiByb2xlPSJpbWciIGFyaWEtbGFiZWw9ImQ0bTF0czogMjAyMSI+PHRpdGxlPmQ0bTF0czogMjAyMTwvdGl0bGU+PGxpbmVhckdyYWRpZW50IGlkPSJzIiB4Mj0iMCIgeTI9IjEwMCUiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2JiYiIgc3RvcC1vcGFjaXR5PSIuMSIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1vcGFjaXR5PSIuMSIvPjwvbGluZWFyR3JhZGllbnQ+PGNsaXBQYXRoIGlkPSJyIj48cmVjdCB3aWR0aD0iMTA1IiBoZWlnaHQ9IjIwIiByeD0iMyIgZmlsbD0iI2ZmZiIvPjwvY2xpcFBhdGg+PGcgY2xpcC1wYXRoPSJ1cmwoI3IpIj48cmVjdCB3aWR0aD0iNjgiIGhlaWdodD0iMjAiIGZpbGw9IiNiZmJmYmYiLz48cmVjdCB4PSI2OCIgd2lkdGg9IjM3IiBoZWlnaHQ9IjIwIiBmaWxsPSIjZmY3NTFhIi8+PHJlY3Qgd2lkdGg9IjEwNSIgaGVpZ2h0PSIyMCIgZmlsbD0idXJsKCNzKSIvPjwvZz48ZyBmaWxsPSIjZmZmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0iVmVyZGFuYSxHZW5ldmEsRGVqYVZ1IFNhbnMsc2Fucy1zZXJpZiIgdGV4dC1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiIgZm9udC1zaXplPSIxMTAiPjxpbWFnZSB4PSI1IiB5PSIzIiB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5Qm1hV3hzUFNJak0yTXpZek5rSWlCeWIyeGxQU0pwYldjaUlIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhkR2wwYkdVK1JYUm9aWEpsZFcwOEwzUnBkR3hsUGp4d1lYUm9JR1E5SWsweE1TNDVORFFnTVRjdU9UZE1OQzQxT0NBeE15NDJNaUF4TVM0NU5ETWdNalJzTnk0ek55MHhNQzR6T0MwM0xqTTNNaUEwTGpNMWFDNHdNRE42VFRFeUxqQTFOaUF3VERRdU5qa2dNVEl1TWpJemJEY3VNelkxSURRdU16VTBJRGN1TXpZMUxUUXVNelZNTVRJdU1EVTJJREI2SWk4K1BDOXpkbWMrIi8+PHRleHQgYXJpYS1oaWRkZW49InRydWUiIHg9IjQzNSIgeT0iMTUwIiBmaWxsPSIjY2NjIiBmaWxsLW9wYWNpdHk9Ii4zIiB0cmFuc2Zvcm09InNjYWxlKC4xKSIgdGV4dExlbmd0aD0iNDEwIj5kNG0xdHM8L3RleHQ+PHRleHQgeD0iNDM1IiB5PSIxNDAiIHRyYW5zZm9ybT0ic2NhbGUoLjEpIiBmaWxsPSIjMzMzIiB0ZXh0TGVuZ3RoPSI0MTAiPmQ0bTF0czwvdGV4dD48dGV4dCBhcmlhLWhpZGRlbj0idHJ1ZSIgeD0iODU1IiB5PSIxNTAiIGZpbGw9IiMwMTAxMDEiIGZpbGwtb3BhY2l0eT0iLjMiIHRyYW5zZm9ybT0ic2NhbGUoLjEpIiB0ZXh0TGVuZ3RoPSIyNzAiPjIwMjE8L3RleHQ+PHRleHQgeD0iODU1IiB5PSIxNDAiIHRyYW5zZm9ybT0ic2NhbGUoLjEpIiBmaWxsPSIjZmZmIiB0ZXh0TGVuZ3RoPSIyNzAiPjIwMjE8L3RleHQ+PC9nPjwvc3ZnPg==" width="105" height="20" class="img_ev3q"></p>
<header><h1>类的加载机制</h1></header>
<p>Java是一个依赖于JVM(Java虚拟机)实现的跨平台的开发语言。Java程序在运行前需要先编译成<code>class文件</code>，Java类初始化的时候会调用 <code>java.lang.ClassLoader</code>加载类字节码，<code>ClassLoader</code>会调用JVM的native方法(<code>defineClass0/1/2</code>)来定义一个<code>java.lang.Class</code>实例。</p>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>
<h1>类的生命周期</h1>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，<strong>它的整个生命周期包括：加载，校验，准备，解析，初始化,使用,卸载</strong>这7个阶段.其中其中验证、准备、解析3个部分统称为链接。</p>
<p><img decoding="async" loading="lazy" alt="JVM - 类加载机制" src="/assets/images/7f76359d03f0891d0019bbc3a322d5bd-d87e6febaa3a13e057260391b60fd03f.png" width="1272" height="692" class="img_ev3q"></p>
<p>加载、校验、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）</p>
<p><strong>注意，这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</strong></p>
<p><img decoding="async" loading="lazy" alt="Java虚拟机：类加载过程" src="/assets/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDYzMzI3NQ==,size_16,color_FFFFFF,t_70-73206b554be72ef374fcab1f805f2054.jpg" width="994" height="796" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="加载查找并加载类的二进制数据">加载：查找并加载类的二进制数据<a href="#加载查找并加载类的二进制数据" class="hash-link" aria-label="加载：查找并加载类的二进制数据的直接链接" title="加载：查找并加载类的二进制数据的直接链接">​</a></h2>
<p>在加载阶段，虚拟机需要完成以下3件事情：</p>
<ul>
<li>1）通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="校验确保被加载的类的正确性">校验：确保被加载的类的正确性<a href="#校验确保被加载的类的正确性" class="hash-link" aria-label="校验：确保被加载的类的正确性的直接链接" title="校验：确保被加载的类的正确性的直接链接">​</a></h2>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作:</p>
<ul>
<li><strong>文件格式验证</strong>: 验证字节流是否符合Class文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="准备为类的静态变量分配内存并将其初始化为默认值">准备：为类的静态变量分配内存，并将其初始化为默认值<a href="#准备为类的静态变量分配内存并将其初始化为默认值" class="hash-link" aria-label="准备：为类的静态变量分配内存，并将其初始化为默认值的直接链接" title="准备：为类的静态变量分配内存，并将其初始化为默认值的直接链接">​</a></h2>
<p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配</strong>。</p>
<p>该阶段的注意事项：</p>
<ul>
<li>
<p>这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li>
<p>这里所设置的初始值通常情况下是数据类型默认的零值(如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等)，而不是被在Java代码中被显式地赋予的值。</p>
<blockquote>
<p>比如：假设一个类变量的定义为: <code>public static int value = 3</code>；那么变量value在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>()</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
</blockquote>
</li>
<li>
<p>对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</p>
</li>
<li>
<p>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<code>final</code>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</p>
</li>
<li>
<p>对于引用数据类型<code>reference</code>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</p>
</li>
<li>
<p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</p>
</li>
<li>
<p>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被<code>final</code>和<code>static</code>修饰，那么在准备阶段变量<code>value</code>就会被初始化为<code>ConstValue</code>属性所指定的值。</p>
<blockquote>
<p>假设上面的类变量value被定义为: <code>public static final int value = 3；</code>编译时Javac将会为value生成<code>ConstantValue</code>属性，在准备阶段虚拟机就会根据<code>ConstantValue</code>的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</p>
</blockquote>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="解析把类中的符号引用转换为直接引用">解析：把类中的符号引用转换为直接引用<a href="#解析把类中的符号引用转换为直接引用" class="hash-link" aria-label="解析：把类中的符号引用转换为直接引用的直接链接" title="解析：把类中的符号引用转换为直接引用的直接链接">​</a></h2>
<p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</strong>，解析动作主要针对<code>类</code>或<code>接口</code>、<code>字段</code>、<code>类方法</code>、<code>接口方法</code>、<code>方法类型</code>、<code>方法句柄</code>和<code>调用点</code>限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p><code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="初始化对类的静态变量静态代码块执行初始化操作">初始化：对类的静态变量，静态代码块执行初始化操作<a href="#初始化对类的静态变量静态代码块执行初始化操作" class="hash-link" aria-label="初始化：对类的静态变量，静态代码块执行初始化操作的直接链接" title="初始化：对类的静态变量，静态代码块执行初始化操作的直接链接">​</a></h2>
<p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p>
<ol>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="类初始化的步骤">类初始化的步骤<a href="#类初始化的步骤" class="hash-link" aria-label="类初始化的步骤的直接链接" title="类初始化的步骤的直接链接">​</a></h3>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="触发类初始化的时机"><strong>触发类初始化的时机</strong><a href="#触发类初始化的时机" class="hash-link" aria-label="触发类初始化的时机的直接链接" title="触发类初始化的时机的直接链接">​</a></h3>
<p>只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p>
<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="以下几种情况不会执行类初始化">以下几种情况不会执行类初始化<a href="#以下几种情况不会执行类初始化" class="hash-link" aria-label="以下几种情况不会执行类初始化的直接链接" title="以下几种情况不会执行类初始化的直接链接">​</a></h3>
<ol>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li>
<li>通过类名获取 Class 对象，不会触发类的初始化。</li>
<li>通过 <code>Class.forName</code> 加载指定类时，如果指定参数 <code>initialize</code> 为 <code>false</code> 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li>
<li>通过 <code>ClassLoader</code> 默认的 <code>loadClass</code> 方法，也不会触发初始化动作。</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="使用">使用<a href="#使用" class="hash-link" aria-label="使用的直接链接" title="使用的直接链接">​</a></h2>
<p>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="卸载">卸载<a href="#卸载" class="hash-link" aria-label="卸载的直接链接" title="卸载的直接链接">​</a></h2>
<p><strong>Java虚拟机将结束生命周期的几种情况</strong></p>
<ul>
<li>执行了<code>System.exit()</code>方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h1>类加载器</h1>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是类加载器">什么是类加载器<a href="#什么是类加载器" class="hash-link" aria-label="什么是类加载器的直接链接" title="什么是类加载器的直接链接">​</a></h2>
<p>虚拟机设计团队把类加载阶段中的==通过一个类的全限定名来获取描述此类的二进制字节流==这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为<strong>类加载器</strong>。</p>
<p>一切的Java类都必须经过JVM加载后才能运行，而<code>ClassLoader</code>的主要作用就是Java类文件的加载。</p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每个类加载器都拥有一个独立的类命名空间。也就是说：比较两个类是否「相等」，要在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类加载器的层次">类加载器的层次<a href="#类加载器的层次" class="hash-link" aria-label="类加载器的层次的直接链接" title="类加载器的层次的直接链接">​</a></h2>
<p><img decoding="async" loading="lazy" alt="类加载层次" src="/assets/images/类加载层次-3c8ec34253b39dcccae635fa18e59e81.jpg" width="1464" height="1435" class="img_ev3q"></p>
<p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：</p>
<ul>
<li>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分，负责加载JDK中的核心类库，类似于操作系统启动时的boot loader</li>
<li>另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</li>
</ul>
<p>从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器:</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="启动类加载器bootstrap-classloader">启动类加载器(Bootstrap ClassLoader)<a href="#启动类加载器bootstrap-classloader" class="hash-link" aria-label="启动类加载器(Bootstrap ClassLoader)的直接链接" title="启动类加载器(Bootstrap ClassLoader)的直接链接">​</a></h3>
<ul>
<li>
<p>启动类加载器是最底层的类加载器，是JVM的一部分，它是由C++语言实现的，且没有父加载器，也没有继承<code>java.lang.ClassLodaer</code>类。</p>
</li>
<li>
<p>这个类加载器负责将存放在<code>＜JAVA_HOME＞/lib</code>和<code>＜JAVA_HOME＞/jre/lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。（按照文件名识别，如<code>tools.jar</code>、<code>rt.jar</code>，名字不符合的类库即使放在lib目录中也不会被加载）</p>
</li>
<li>
<p>处于安全考虑，根类加载器只加载<code>java</code>、<code>javax</code>、<code>sun</code>开头的类。</p>
</li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20211026165544725" src="/assets/images/image-20211026165544725-dc9ba4c7e69a29dc37eeac9d6aee25aa.png" width="1670" height="542" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class TestClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args)  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(java.lang.String.class.getClassLoader());    // null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="扩展类加载器extension-classloader">扩展类加载器(Extension ClassLoader)<a href="#扩展类加载器extension-classloader" class="hash-link" aria-label="扩展类加载器(Extension ClassLoader)的直接链接" title="扩展类加载器(Extension ClassLoader)的直接链接">​</a></h3>
<ul>
<li>这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>＜JAVA_HOME＞/lib/ext</code>和<code>＜JAVA_HOME＞/jre/lib/ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20211027112003516" src="/assets/images/image-20211027112003516-afe0143be87dde4a992bc422735c4783.png" width="1772" height="548" class="img_ev3q"></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class TestClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args)  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(com.sun.nio.zipfs.ZipFileStore.class.getClassLoader());  // sun.misc.Launcher$ExtClassLoader@6bc168e5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="应用程序类加载器application-classloader">应用程序类加载器(Application ClassLoader)<a href="#应用程序类加载器application-classloader" class="hash-link" aria-label="应用程序类加载器(Application ClassLoader)的直接链接" title="应用程序类加载器(Application ClassLoader)的直接链接">​</a></h3>
<p>这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现。</p>
<p>由于应用程序类加载器是<code>ClassLoader</code>类中的<code>getSystemClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br></span></code></pre></div></div>
<p>它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。<strong>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</strong></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class TestClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args)  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(TestClassLoader.class.getClassLoader());  // sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="注意">注意<a href="#注意" class="hash-link" aria-label="注意的直接链接" title="注意的直接链接">​</a></h3>
<p>某些时候我们获取一个类的类加载器时候可能会返回一个<code>null</code>值，如:<code>java.io.File.class.getClassLoader()</code>将返回一个<code>null</code>对象，因为<code>java.io.File</code>类在JVM初始化的时候会被<code>Bootstrap ClassLoader(引导类加载器)</code>加载(该类加载器实现于JVM层，采用C++编写)，我们在尝试获取被<code>Bootstrap ClassLoader</code>类加载器所加载的类的<code>ClassLoader</code>时候都会返回<code>null</code>。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.File;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TestClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(File.class.getClassLoader());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类加载的几种方式">类加载的几种方式<a href="#类加载的几种方式" class="hash-link" aria-label="类加载的几种方式的直接链接" title="类加载的几种方式的直接链接">​</a></h2>
<p>Java类加载方式分为<code>显式</code>和<code>隐式</code>,<code>显式</code>即我们通常使用<code>Java反射</code>或者<code>ClassLoader</code>来动态加载一个类对象，而<code>隐式</code>指的是<code>类名.方法名()</code>或<code>new</code>类实例。<code>显式</code>类加载方式也可以理解为类动态加载，我们可以自定义类加载器去加载任意的类。</p>
<ol>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过<code>Class.forName()</code>方法动态加载</li>
<li>通过<code>ClassLoader.loadClass()</code>方法动态加载</li>
</ol>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class TestClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 默认会执行初始化静态代码块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class.forName(&quot;Test&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用应用程序类加载器来加载类Test，不会执行初始化静态代码块</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        appClassLoader.loadClass(&quot;Test&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //forName指定了classLoader，initialize为false不会执行初始化静态代码块，为true则会执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class.forName(&quot;Test&quot;, false, appClassLoader);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;静态方法被执行了&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>分别运行上面几种类加载方式，可以看出来<code>Class.forName()</code>和<code>ClassLoader.loadClass()</code>的区别</p>
<ul>
<li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在<code>newInstance()</code>才会去执行static块;</li>
<li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了<code>newInstance()</code>方法采用调用构造函数，创建类的对象。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="jvm类加载机制">JVM类加载机制<a href="#jvm类加载机制" class="hash-link" aria-label="JVM类加载机制的直接链接" title="JVM类加载机制的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="全盘负责">全盘负责<a href="#全盘负责" class="hash-link" aria-label="全盘负责的直接链接" title="全盘负责的直接链接">​</a></h3>
<p>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="父类委托">父类委托<a href="#父类委托" class="hash-link" aria-label="父类委托的直接链接" title="父类委托的直接链接">​</a></h3>
<p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="缓存机制">缓存机制<a href="#缓存机制" class="hash-link" aria-label="缓存机制的直接链接" title="缓存机制的直接链接">​</a></h3>
<p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="双亲委派机制">双亲委派机制<a href="#双亲委派机制" class="hash-link" aria-label="双亲委派机制的直接链接" title="双亲委派机制的直接链接">​</a></h3>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类的双亲委派机制">类的双亲委派机制<a href="#类的双亲委派机制" class="hash-link" aria-label="类的双亲委派机制的直接链接" title="类的双亲委派机制的直接链接">​</a></h2>
<p><img decoding="async" loading="lazy" alt="类加载器双亲委派模型" src="/assets/images/类加载层次-3c8ec34253b39dcccae635fa18e59e81.jpg" width="1464" height="1435" class="img_ev3q"></p>
<p>上图展示的类加载器之间的这种层次关系，称为类加载器的<strong>双亲委派模型</strong>（Parents Delegation Model）。</p>
<p><strong>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码</strong>。</p>
<blockquote>
<p>类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式.</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="双亲委派机制的工作流程">双亲委派机制的工作流程<a href="#双亲委派机制的工作流程" class="hash-link" aria-label="双亲委派机制的工作流程的直接链接" title="双亲委派机制的工作流程的直接链接">​</a></h3>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<p>举例：</p>
<ol>
<li>当<code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li>
<li>如果<code>BootStrapClassLoader</code>加载失败(例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该class)，会使用<code>ExtClassLoader</code>来尝试加载；</li>
<li>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</li>
</ol>
<p>代码举例：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 输出结果：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * sun.misc.Launcher$ExtClassLoader@61064425</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TestClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ClassLoader loader= TestClassLoader.class.getClassLoader();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(loader!=null){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(loader);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            loader=loader.getParent();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(loader);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="双亲委派机制的优点">双亲委派机制的优点<a href="#双亲委派机制的优点" class="hash-link" aria-label="双亲委派机制的优点的直接链接" title="双亲委派机制的优点的直接链接">​</a></h3>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<p>例如类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为<code>java.lang.Object</code>的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p>
<p>所以它的优点</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
<p><img decoding="async" loading="lazy" alt="双亲委派" src="/assets/images/2505886_1564538979490_D5D109BB8EA439F60D4960AF194310AF-7214be3e1fa0d11c1f3860b994c5afcc.png" width="1149" height="923" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="双亲委派机制代码实现">双亲委派机制代码实现<a href="#双亲委派机制代码实现" class="hash-link" aria-label="双亲委派机制代码实现的直接链接" title="双亲委派机制代码实现的直接链接">​</a></h3>
<p>代码实现主要在<code>ClassLoader</code>类的<code>loadClass</code>函数中</p>
<p><img decoding="async" loading="lazy" alt="image-20211026190831757" src="/assets/images/image-20211026190831757-51b59e59d1869cd4627f13bb1e25b9ce.png" width="3584" height="2240" class="img_ev3q"></p>
<p>由此也可看出，<strong>我们如果要自定义一个类加载器，那么需要重写的就是<code>findClass()</code>方法，而不是<code>loadClass()</code>方法</strong></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="类加载器的核心方法">类加载器的核心方法<a href="#类加载器的核心方法" class="hash-link" aria-label="类加载器的核心方法的直接链接" title="类加载器的核心方法的直接链接">​</a></h2>
<ol>
<li><code>loadClass</code>(加载指定的Java类)</li>
<li><code>findClass</code>(查找指定的Java类)</li>
<li><code>findLoadedClass</code>(查找JVM已经加载过的类)</li>
<li><code>defineClass</code>(定义一个Java类)</li>
<li><code>resolveClass</code>(链接指定的Java类)</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="自定义类加载器">自定义类加载器<a href="#自定义类加载器" class="hash-link" aria-label="自定义类加载器的直接链接" title="自定义类加载器的直接链接">​</a></h2>
<p>通常情况下，我们都是直接使用系统类加载器。但是有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。</p>
<blockquote>
<p>利用自定义类加载器我们可以在webshell中实现加载并调用自己编译的类对象，比如本地命令执行漏洞调用自定义类字节码的native方法绕过RASP检测，也可以用于加密重要的Java类字节码(只能算弱加密了)。</p>
</blockquote>
<p><strong>自定义类加载器一般都是继承自<code>ClassLoader</code>类</strong>，从上面对<code>loadClass</code>方法来<a href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">分析</a>来看，我们只需要重写 <code>findClass</code> 方法即可。</p>
<p><strong>注意：</strong></p>
<ol>
<li>这里传递的文件名需要是类的全限定性名称，即<code>com.test.Test</code>格式的，因为 <code>defineClass</code> 方法是按这种格式进行处理的。</li>
<li>最好不要重写<code>loadClass</code>方法，因为这样容易破坏双亲委托模式。</li>
<li>这类Test类本身可以被 AppClassLoader 类加载，因此我们不能把<code>com/test/Test</code> 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</li>
</ol>
<p><strong>举例：此处我通过本地class文件的字节码来加载class</strong></p>
<ul>
<li>
<p>需要加载的class源码</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.BufferedReader;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.InputStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.InputStreamReader;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Exploit{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Exploit() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Process p = Runtime.getRuntime().exec(new String[]{&quot;open&quot;, &quot;-na&quot;, &quot;Calculator&quot;});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InputStream is = p.getInputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BufferedReader reader = new BufferedReader(new InputStreamReader(is));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String line;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while((line = reader.readLine()) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        p.waitFor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        is.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reader.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        p.destroy();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}    </span><br></span></code></pre></div></div>
</li>
<li>
<p>编译成class文件</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">javac Exploit.java</span><br></span></code></pre></div></div>
<p>JVM执行的其实就是<code>javap</code>命令生成的字节码(<code>ByteCode</code>)。</p>
<p><img decoding="async" loading="lazy" alt="image-20211027094622772" src="/assets/images/image-20211027094622772-18b1187f43cc118d995558e836614f38.png" width="2378" height="2180" class="img_ev3q"></p>
</li>
<li>
<p>编写<code>TestClassLoader</code>加载这个class</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.ByteArrayOutputStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.FileInputStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.IOException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.InputStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TestClassLoader extends ClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 重写了findClass方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        byte[] bytes = new byte[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            bytes = loadClassData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (bytes == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new ClassNotFoundException(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return defineClass(&quot;Exploit&quot;, bytes, 0, bytes.length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 给class文件以字节码的形式返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private byte[] loadClassData() throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String fileName = &quot;/Users/d4m1ts/d4m1ts/tools/exp/exphub/fastjson/Exploit.class&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            InputStream ins = new FileInputStream(fileName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int bufferSize = 1024;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            byte[] buffer = new byte[bufferSize];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int length = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while ((length = ins.read(buffer)) != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                baos.write(buffer, 0, length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return baos.toByteArray();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TestClassLoader testClassLoader = new TestClassLoader();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // loadClass的时候上层的ClassLoader都找不到对应的类，所以会调用它自己的findClass去加载类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class&lt;?&gt; test = testClassLoader.loadClass(&quot;Exploit&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(test.getClassLoader());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 申请实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        test.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
</li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20211027090528372" src="/assets/images/image-20211027090528372-941ce16a9ecb8dddffc52decee14319b.png" width="3582" height="1692" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="urlclassloader">URLClassLoader<a href="#urlclassloader" class="hash-link" aria-label="URLClassLoader的直接链接" title="URLClassLoader的直接链接">​</a></h2>
<p><code>URLClassLoader</code>继承了<code>ClassLoader</code>，<code>URLClassLoader</code>提供了加载远程资源的能力，在写漏洞利用的<code>payload</code>或者<code>webshell</code>的时候我们可以使用这个特性来加载远程的jar来实现远程的类方法调用。</p>
<blockquote>
<p>远程类我们还是使用我们<a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">自定义类加载器</a>中编译的<code>Exploit.class</code>吧</p>
<p>下方命令给class打包成jar，也可以直接压缩为zip再改后缀</p>
<pre tabindex="0" class="codeBlockStandalone_MEMb thin-scrollbar language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"></code></pre>
</blockquote>
<p>jar cvf Exploit.jar Exploit.class</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">编写远程加载jar代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">```java</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.IOException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.net.URL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.net.URLClassLoader;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TestClassLoader {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 也可以搭建个web服务器用http协议来远程加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    URL url = new URL(&quot;file:/Users/d4m1ts/d4m1ts/tools/exp/exphub/fastjson/Exploit.jar&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{url});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; exploit = urlClassLoader.loadClass(&quot;Exploit&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    exploit.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><img decoding="async" loading="lazy" alt="image-20211027111441398" src="/assets/images/image-20211027111441398-b1ed07a5d78c5239a6d08c4fa42410a7.png" width="2404" height="824" class="img_ev3q"></p>
<h1>参考</h1>
<ul>
<li><a href="https://juejin.cn/post/6865572557329072141" target="_blank" rel="noopener noreferrer">关于JVM类加载机制，看这一篇就够了</a></li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">最后<!-- -->由 <b>d4m1ts</b> <!-- -->于 <b><time datetime="2025-06-01T04:26:30.000Z" itemprop="dateModified">2025年6月1日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/category/审计基础"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">审计基础</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/代码审计/Java安全/审计基础/Java反射机制"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Java反射机制</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#加载查找并加载类的二进制数据" class="table-of-contents__link toc-highlight">加载：查找并加载类的二进制数据</a></li><li><a href="#校验确保被加载的类的正确性" class="table-of-contents__link toc-highlight">校验：确保被加载的类的正确性</a></li><li><a href="#准备为类的静态变量分配内存并将其初始化为默认值" class="table-of-contents__link toc-highlight">准备：为类的静态变量分配内存，并将其初始化为默认值</a></li><li><a href="#解析把类中的符号引用转换为直接引用" class="table-of-contents__link toc-highlight">解析：把类中的符号引用转换为直接引用</a></li><li><a href="#初始化对类的静态变量静态代码块执行初始化操作" class="table-of-contents__link toc-highlight">初始化：对类的静态变量，静态代码块执行初始化操作</a><ul><li><a href="#类初始化的步骤" class="table-of-contents__link toc-highlight">类初始化的步骤</a></li><li><a href="#触发类初始化的时机" class="table-of-contents__link toc-highlight"><strong>触发类初始化的时机</strong></a></li><li><a href="#以下几种情况不会执行类初始化" class="table-of-contents__link toc-highlight">以下几种情况不会执行类初始化</a></li></ul></li><li><a href="#使用" class="table-of-contents__link toc-highlight">使用</a></li><li><a href="#卸载" class="table-of-contents__link toc-highlight">卸载</a></li><li><a href="#什么是类加载器" class="table-of-contents__link toc-highlight">什么是类加载器</a></li><li><a href="#类加载器的层次" class="table-of-contents__link toc-highlight">类加载器的层次</a><ul><li><a href="#启动类加载器bootstrap-classloader" class="table-of-contents__link toc-highlight">启动类加载器(Bootstrap ClassLoader)</a></li><li><a href="#扩展类加载器extension-classloader" class="table-of-contents__link toc-highlight">扩展类加载器(Extension ClassLoader)</a></li><li><a href="#应用程序类加载器application-classloader" class="table-of-contents__link toc-highlight">应用程序类加载器(Application ClassLoader)</a></li><li><a href="#注意" class="table-of-contents__link toc-highlight">注意</a></li></ul></li><li><a href="#类加载的几种方式" class="table-of-contents__link toc-highlight">类加载的几种方式</a></li><li><a href="#jvm类加载机制" class="table-of-contents__link toc-highlight">JVM类加载机制</a><ul><li><a href="#全盘负责" class="table-of-contents__link toc-highlight">全盘负责</a></li><li><a href="#父类委托" class="table-of-contents__link toc-highlight">父类委托</a></li><li><a href="#缓存机制" class="table-of-contents__link toc-highlight">缓存机制</a></li><li><a href="#双亲委派机制" class="table-of-contents__link toc-highlight">双亲委派机制</a></li></ul></li><li><a href="#类的双亲委派机制" class="table-of-contents__link toc-highlight">类的双亲委派机制</a><ul><li><a href="#双亲委派机制的工作流程" class="table-of-contents__link toc-highlight">双亲委派机制的工作流程</a></li><li><a href="#双亲委派机制的优点" class="table-of-contents__link toc-highlight">双亲委派机制的优点</a></li><li><a href="#双亲委派机制代码实现" class="table-of-contents__link toc-highlight">双亲委派机制代码实现</a></li></ul></li><li><a href="#类加载器的核心方法" class="table-of-contents__link toc-highlight">类加载器的核心方法</a></li><li><a href="#自定义类加载器" class="table-of-contents__link toc-highlight">自定义类加载器</a></li><li><a href="#urlclassloader" class="table-of-contents__link toc-highlight">URLClassLoader</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">内容导航</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/friends">友情链接</a></li><li class="footer__item"><a class="footer__link-item" href="/promotions">我的推广</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">实用工具</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://markdown.gm7.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item">在线Markdown<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://rshell.gm7.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Reverse Shell Generator<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://gtfobins.gm7.org/" target="_blank" rel="noopener noreferrer" class="footer__link-item">GTFOBins<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">关注我</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/damit5/damit5.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="mailto:admin@gm7.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">联系我<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 d4m1ts 知识库</div></div></div></footer></div>
</body>
</html>